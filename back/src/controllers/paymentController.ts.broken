import { Request, Response } from "express";
import { PrismaClient } from '../generated/prisma';
import { PaymentService } from "../services/PaymentService";
// import { LavaTopSDKService } from "../services/LavaTopSDKService"; // Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾
import logger from "../utils/logger";
import axios, { AxiosError } from "axios";

// Create a new payment
export const createPayment = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { amount, currency, type } = req.body;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!amount || !currency || !type) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    const payment = await prisma.payment.create({
      data: {
        userId,
        amount,
        currency,
        status: "PENDING",
      },
    });

    res.status(201).json(payment);
  } catch (error) {
    console.error("Error creating payment:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Get payment history
export const getPaymentHistory = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { page = 1, limit = 10 } = req.query;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const skip = (Number(page) - 1) * Number(limit);

    const payments = await prisma.payment.findMany({
      where: { userId },
      skip,
      take: Number(limit),
      orderBy: { createdAt: "desc" },
    });

    const totalCount = await prisma.payment.count({
      where: { userId },
    });

    res.json({
      payments,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / Number(limit)),
      },
    });
  } catch (error) {
    console.error("Error fetching payment history:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Get token history
export const getTokenHistory = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { page = 1, limit = 10 } = req.query;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const skip = (Number(page) - 1) * Number(limit);

    const tokenHistory = await prisma.tokenHistory.findMany({
      where: { userId },
      skip,
      take: Number(limit),
      orderBy: { createdAt: "desc" },
    });

    const totalCount = await prisma.tokenHistory.count({
      where: { userId },
    });

    res.json({
      tokenHistory,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / Number(limit)),
      },
    });
  } catch (error) {
    console.error("Error fetching token history:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Buy tokens
export const buyTokens = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { amount, paymentMethod } = req.body;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: "Invalid token amount" });
    }

    // Check if user has active subscription
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { subscription: true },
    });

    if (!user?.subscription) {
      return res.status(403).json({ error: "Active subscription required to buy tokens" });
    }

    // Create payment record
    const payment = await prisma.payment.create({
      data: {
        userId,
        amount: amount * 1.4342, // Price per token in stars
        currency: "STARS",
        status: "PENDING",
      },
    });

    // In a real application, you would integrate with a payment provider here
    // For now, we'll simulate a successful payment

    // Update payment status
    await prisma.payment.update({
      where: { id: payment.id },
      data: { status: "COMPLETED" },
    });

    // Get current user balance before update
    const userBefore = await prisma.user.findUnique({
      where: { id: userId },
      select: { tokens: true },
    });
    
    if (!userBefore) {
      throw new Error("User not found");
    }

    const balanceBefore = userBefore.tokens;
    const balanceAfter = balanceBefore + amount;

    // Add tokens to user
    await prisma.user.update({
      where: { id: userId },
      data: {
        tokens: { increment: amount },
      },
    });

    // Create token history record
    await prisma.tokenHistory.create({
      data: {
        userId,
        amount,
        type: "PURCHASE",
        balanceBefore,
        balanceAfter,
        description: `Token purchase via payment`,
        paymentId: payment.id,
      },
    });

    res.json({
      success: true,
      payment,
      tokensAdded: amount,
    });
  } catch (error) {
    console.error("Error buying tokens:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Update subscription
export const updateSubscription = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { plan, duration = 1 } = req.body;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    const validPlans = ["base", "pro", "premium"];
    if (!validPlans.includes(plan)) {
      return res.status(400).json({ error: "Invalid subscription plan" });
    }

    // Calculate price based on plan
    const prices = {
      base: { rub: 920, eur: 9.5, usd: 10, tokens: 100 },
      pro: { rub: 2760, eur: 28.5, usd: 30, tokens: 300 },
      premium: { rub: 4600, eur: 47.5, usd: 50, tokens: 600 },
    };

    const planPrice = prices[plan as keyof typeof prices];

    // Create payment record
    const payment = await prisma.payment.create({
      data: {
        userId,
        amount: planPrice.rub * duration,
        currency: "RUB",
        status: "PENDING",
      },
    });

    // In a real application, you would integrate with a payment provider here
    // For now, we'll simulate a successful payment

    // Update payment status
    await prisma.payment.update({
      where: { id: payment.id },
      data: { status: "COMPLETED" },
    });

    // Get current user balance before update
    const userBefore = await prisma.user.findUnique({
      where: { id: userId },
      select: { tokens: true },
    });
    
    if (!userBefore) {
      throw new Error("User not found");
    }

    const tokenAmount = planPrice.tokens * duration;
    const balanceBefore = userBefore.tokens;
    const balanceAfter = balanceBefore + tokenAmount;

    // Update user subscription and add tokens
    await prisma.user.update({
      where: { id: userId },
      data: {
        subscription: plan as any,
        tokens: { increment: tokenAmount },
      },
    });

    // Create token history record
    await prisma.tokenHistory.create({
      data: {
        userId,
        amount: tokenAmount,
        type: "PURCHASE",
        balanceBefore,
        balanceAfter,
        description: `Subscription purchase: ${plan} for ${duration} month(s)`,
        paymentId: payment.id,
      },
    });

    res.json({
      success: true,
      payment,
      subscription: plan,
      tokensAdded: planPrice.tokens * duration,
    });
  } catch (error) {
    console.error("Error updating subscription:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Get subscription plans
export const getSubscriptionPlans = async (req: Request, res: Response) => {
  try {
    // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¿Ð»Ð°Ð½Ñ‹ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
    const dbPlans = await prisma.subscriptionPlan.findMany({
      where: { isActive: true },
      orderBy: { priceRub: 'asc' }
    });

    logger.info(`Found ${dbPlans.length} subscription plans in database`);
    logger.info('Plans data:', JSON.stringify(dbPlans, null, 2));
    
    // Ð•ÑÐ»Ð¸ Ð¿Ð»Ð°Ð½Ñ‹ ÐµÑÑ‚ÑŒ Ð² Ð‘Ð”, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð¸Ñ…
    if (dbPlans && dbPlans.length > 0) {
      
      const plans = dbPlans.map(plan => {
        // ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ features - Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¼Ð°ÑÑÐ¸Ð² Ð¸Ð»Ð¸ Ð¾Ð±ÑŠÐµÐºÑ‚
        let features: string[] = [];
        if (Array.isArray(plan.features)) {
          features = (plan.features as any[]).filter(v => typeof v === 'string');
        } else if (typeof plan.features === 'object' && plan.features !== null) {
          // Ð•ÑÐ»Ð¸ ÑÑ‚Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚, Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð¼Ð°ÑÑÐ¸Ð²
          features = Object.values(plan.features as any).filter(v => typeof v === 'string');
        }
        
        return {
          id: plan.name,
          name: plan.displayName,
          displayName: plan.displayName,  // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ displayName Ð´Ð»Ñ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸
          price: { 
            rub: plan.priceRub, 
            eur: plan.priceEur / 100, // ÐºÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ñ†ÐµÐ½Ñ‚Ñ‹ Ð² ÐµÐ²Ñ€Ð¾
            usd: plan.priceUsd / 100  // ÐºÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ñ†ÐµÐ½Ñ‚Ñ‹ Ð² Ð´Ð¾Ð»Ð»Ð°Ñ€Ñ‹
          },
          tokens: plan.tokens,
          features: features,
          description: plan.description || ''
        };
      });
      
      logger.info('Returning plans:', JSON.stringify(plans, null, 2));
      
      // ÐžÑ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ ÐºÑÑˆ Ð´Ð»Ñ Ð¿Ð»Ð°Ð½Ð¾Ð²
      res.set({
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      });
      
      return res.status(200).json(plans);
    }
    
    // Fallback: ÐµÑÐ»Ð¸ Ð² Ð‘Ð” Ð½ÐµÑ‚ Ð¿Ð»Ð°Ð½Ð¾Ð², Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð´ÐµÑ„Ð¾Ð»Ñ‚Ð½Ñ‹Ðµ
    logger.warn("No plans found in database, using fallback plans");
    const fallbackPlans = [
      {
        id: "basic",
        name: "Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        displayName: "Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        price: { rub: 499, eur: 4.99, usd: 5.00 },
        tokens: 1000,
        features: ["Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº AI Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹ Ð¸ Ð²Ð¸Ð´ÐµÐ¾"],
        description: "Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº AI Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸"
      },
      {
        id: "pro", 
        name: "ÐŸÑ€Ð¾ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        displayName: "ÐŸÑ€Ð¾ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        price: { rub: 1699, eur: 16.99, usd: 18.00 },
        tokens: 5000,
        features: ["ÐŸÑ€Ð¾Ñ„ÐµÑÑÐ¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ ÐºÐ¾ Ð²ÑÐµÐ¼ AI Ð¼Ð¾Ð´ÐµÐ»ÑÐ¼", "ÐŸÑ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚Ð½Ð°Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ°"],
        description: "ÐŸÑ€Ð¾Ñ„ÐµÑÑÐ¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿"
      },
      {
        id: "premium",
        name: "ÐŸÑ€ÐµÐ¼Ð¸ÑƒÐ¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°", 
        displayName: "ÐŸÑ€ÐµÐ¼Ð¸ÑƒÐ¼ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        price: { rub: 2999, eur: 29.99, usd: 31.00 },
        tokens: 15000,
        features: ["ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ñ„ÐµÑÑÐ¸Ð¾Ð½Ð°Ð»Ð¾Ð²", "API Ð´Ð¾ÑÑ‚ÑƒÐ¿", "ÐšÐ¾Ð¼Ð¼ÐµÑ€Ñ‡ÐµÑÐºÐ°Ñ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ñ"],
        description: "ÐœÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿"
      }
    ];
    
    res.json(fallbackPlans);
  } catch (error) {
    logger.error("Error fetching subscription plans:", error);
    
    // Ð’ ÑÐ»ÑƒÑ‡Ð°Ðµ Ð»ÑŽÐ±Ð¾Ð¹ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ fallback Ð¿Ð»Ð°Ð½Ñ‹
    const fallbackPlans = [
      {
        id: "basic",
        name: "Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        displayName: "Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ°",
        price: { rub: 499, eur: 4.99, usd: 5.00 },
        tokens: 1000,
        features: ["Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº AI Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸"],
        description: "Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿"
      }
    ];
    
    res.json(fallbackPlans);
  }
};

// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Lava Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð° Ð´Ð»Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸
export const createLavaSubscriptionPayment = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { plan, duration = 1 } = req.body;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!plan || !["base", "pro", "premium"].includes(plan)) {
      return res.status(400).json({ error: "Invalid plan" });
    }

    // Ð¦ÐµÐ½Ñ‹ Ð¿Ð»Ð°Ð½Ð¾Ð² Ð² Ñ€ÑƒÐ±Ð»ÑÑ…
    const planPrices = {
      base: 920,
      pro: 2760,
      premium: 4600,
    };

    const amount = planPrices[plan as keyof typeof planPrices] * duration;
    const paymentService = new PaymentService();

    const paymentResult = await paymentService.createPayment({
      userId,
      amount,
      tokensAmount: 0, // Ð”Ð»Ñ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ñ‚Ð¾ÐºÐµÐ½Ñ‹ Ð½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹
      description: `ÐŸÐ¾Ð´Ð¿Ð¸ÑÐºÐ° ${plan} Ð½Ð° ${duration} Ð¼ÐµÑÑÑ†(ÐµÐ²)`,
      successUrl: `${process.env.FRONTEND_URL}/payment/success`,
      failUrl: `${process.env.FRONTEND_URL}/payment/fail`,
    });

    if (paymentResult.success && paymentResult.paymentUrl) {
      res.json({
        success: true,
        paymentId: paymentResult.paymentId,
        paymentUrl: paymentResult.paymentUrl,
      });
    } else {
      res.status(400).json({
        success: false,
        error: paymentResult.error || "Failed to create payment",
      });
    }
  } catch (error) {
    logger.error("Error creating Lava subscription payment:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};

// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ñ‡ÐµÑ€ÐµÐ· Lava.top API (ÑƒÐ¿Ñ€Ð¾Ñ‰ÐµÐ½Ð½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ)
export const createLavaTopSubscription = async (req: Request, res: Response) => {
  try {
    console.log('ðŸŽ¯ CONTROLLER HIT: createLavaTopSubscription');
    console.log('ðŸ” Request details:', {
      method: req.method,
      originalUrl: req.originalUrl,
      body: req.body
    });
    
    logger.info('ðŸ” LAVA TOP: Request received', {
      body: req.body,
      method: req.method,
      url: req.url,
      headers: req.headers
    });

    const { plan, userId } = req.body;

    if (!userId) {
      logger.error('âŒ LAVA TOP: Missing userId');
      return res.status(400).json({ error: "User ID is required" });
    }

    if (!plan || !["basic", "pro", "premium"].includes(plan)) {
      logger.error('âŒ LAVA TOP: Invalid plan', { plan });
      return res.status(400).json({ error: "Invalid plan" });
    }

    logger.info('âœ… LAVA TOP: Request validated', { plan, userId });

    // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð¿Ð»Ð°Ð½ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ð¸Ð· Ð‘Ð”
    const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
      where: { name: plan }
    });
    
    if (!subscriptionPlan) {
      logger.error('Subscription plan not found', { plan });
      return res.status(400).json({ error: 'Subscription plan not found' });
    }

    // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ð¹ email Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
    const userEmail = `user${Date.now()}@aicex.bot`;

    // Fallback URLs ÐµÑÐ»Ð¸ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ Ð½Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐ½Ñ‹
    const backendUrl = process.env.BACKEND_URL || 'https://aicexaibot-production.up.railway.app';
    const frontendUrl = process.env.FRONTEND_URL || 'https://aicexonefrontend-production.up.railway.app';

    // Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð¸Ð½Ð²Ð¾Ð¹ÑÐ°
    const invoiceData = {
      email: userEmail,
      offerId: subscriptionPlan.lavaOfferId,
      currency: 'RUB',
      description: `${subscriptionPlan.displayName} - AICEX AI Bot`,
      webhookUrl: `${backendUrl}/api/webhooks/lava`,
      successUrl: `${frontendUrl.replace(/\/$/, '')}/payment/success`, // Ð£Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð»Ð¸ÑˆÐ½Ð¸Ðµ ÑÐ»ÑÑˆÐ¸
      failUrl: `${frontendUrl.replace(/\/$/, '')}/payment/fail`
    };
    console.log('ðŸ” LAVA API: Request data:', JSON.stringify(invoiceData, null, 2));
    console.log('ðŸ” LAVA API: Has API key:', !!process.env.LAVA_API_KEY);
    console.log('ðŸ” LAVA API: API key length:', process.env.LAVA_API_KEY?.length || 0);

    // Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº LAVA Gate API
    const lavaResult = await createInvoiceSafe(invoiceData, logger);
    
    if (!lavaResult.ok) {
      logger.error('ðŸš¨ LAVA Gate error', {
        status: lavaResult.status,
        data: lavaResult.data,
        payload: invoiceData
      });
      
      return res.status(502).json({
        success: false,
        error: "LAVA_GATEWAY_ERROR",
        lavaStatus: lavaResult.status,
        lavaData: lavaResult.data
      });
    }

    logger.info('âœ… LAVA Gate success', {
      status: lavaResult.status,
      invoiceId: lavaResult.data.id
    });

    if (lavaResult.data.id && lavaResult.data.paymentUrl) {
      // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ðµ Ð² Ð‘Ð”
      await prisma.payment.create({
        data: {
          userId: userId,
          amount: subscriptionPlan.priceRub,
          currency: 'RUB',
          status: 'PENDING',
          provider: 'lava',
          providerId: responseData.id,
          metadata: JSON.stringify({
            lavaInvoiceId: responseData.id,
            offerId: subscriptionPlan.lavaOfferId,
            userEmail: userEmail,
            plan: plan,
            planId: subscriptionPlan.id
          })
        }
      });

      // Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ ÑƒÑÐ¿ÐµÑˆÐ½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚
      const successResponse = {
        success: true,
        paymentId: responseData.id,
        paymentUrl: responseData.paymentUrl,
        amount: subscriptionPlan.priceRub,
        currency: 'RUB'
      };

      console.log('âœ… LAVA API: Success', successResponse);
      return res.status(200).json(successResponse);
      
    } else {
      console.error('âŒ LAVA API: Invalid response status:', response.status);
      console.error('âŒ LAVA API: Response data:', JSON.stringify(responseData, null, 2));
      return res.status(400).json({
        success: false,
        error: responseData.message || responseData.error || 'Payment creation failed'
      });
    }

  } catch (error: any) {
    logger.error('ðŸ’¥ LAVA API: Exception', {
      error: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code
    });
    
    // Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð±Ð¾Ð»ÐµÐµ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½ÑƒÑŽ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ Ð² development
    const isDev = process.env.NODE_ENV === 'development';
    
    return res.status(500).json({ 
      success: false,
      error: error.message || 'Internal server error',
      ...(isDev && { 
        details: error.stack,
        errorName: error.name 
      })
    });
  }
};
// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Lava Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð° Ð´Ð»Ñ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²
export const createLavaTokenPayment = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;
    const { amount } = req.body;

    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: "Invalid token amount" });
    }

    // Ð¦ÐµÐ½Ð° Ð·Ð° Ñ‚Ð¾ÐºÐµÐ½ Ð² Ñ€ÑƒÐ±Ð»ÑÑ… (Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð½Ð¾ 1.43 Ñ€ÑƒÐ±Ð»Ñ Ð·Ð° Ñ‚Ð¾ÐºÐµÐ½)
    const pricePerToken = 1.43;
    const totalPrice = Math.round(amount * pricePerToken);

    const paymentService = new PaymentService();

    const paymentResult = await paymentService.createPayment({
      userId,
      amount: totalPrice,
      tokensAmount: amount,
      description: `ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ° ${amount} Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²`,
      successUrl: `${process.env.FRONTEND_URL}/payment/success`,
      failUrl: `${process.env.FRONTEND_URL}/payment/fail`,
    });

    if (paymentResult.success && paymentResult.paymentUrl) {
      res.json({
        success: true,
        paymentId: paymentResult.paymentId,
        paymentUrl: paymentResult.paymentUrl,
      });
    } else {
      res.status(400).json({
        success: false,
        error: paymentResult.error || "Failed to create payment",
      });
    }
  } catch (error) {
    logger.error("Error creating Lava token payment:", error);
    res.status(500).json({ error: "Internal server error" });
  }
};
