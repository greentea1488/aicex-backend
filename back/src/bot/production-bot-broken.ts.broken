import { Bot } from "grammy";
import { logger } from "../utils/logger";
import { prisma } from "../utils/prismaClient";
import { AIServiceManager } from "../services/ai/AIServiceManager";
import { ChatMessage } from "../services/ai/OpenAIService";

const bot = new Bot(process.env.BOT_TOKEN!);
const aiManager = new AIServiceManager();

console.log("ü§ñ Starting AICEX Production Bot with AI integrations...");

// üéØ –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ - —Ç–æ–ª—å–∫–æ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏
const mainMenu = {
  inline_keyboard: [
    [
      { text: 'üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ—Ç–æ', callback_data: 'generate_image' }
    ],
    [
      { text: 'üé¨ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ', callback_data: 'generate_video' }
    ],
    [
      { text: 'üí¨ –ß–∞—Ç —Å AI', callback_data: 'chat_ai' }
    ],
    [
      { text: 'üåê –í–µ–±-–≤–µ—Ä—Å–∏—è', web_app: { url: process.env.FRONTEND_URL || 'http://localhost:3000' } }
    ]
  ]
};

// üé® –ú–ï–ù–Æ –ì–ï–ù–ï–†–ê–¶–ò–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
const imageMenu = {
  inline_keyboard: [
    [
      { text: 'üé® Freepik AI', callback_data: 'image_freepik' },
      { text: 'üñºÔ∏è Midjourney', callback_data: 'image_midjourney' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üé¨ –ú–ï–ù–Æ –ì–ï–ù–ï–†–ê–¶–ò–ò –í–ò–î–ï–û  
const videoMenu = {
  inline_keyboard: [
    [
      { text: 'üé¨ Freepik Video', callback_data: 'video_freepik' },
      { text: 'üöÄ Runway ML', callback_data: 'video_runway' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üí¨ –ú–ï–ù–Æ –ß–ê–¢–ê
const chatMenu = {
  inline_keyboard: [
    [
      { text: 'üß† ChatGPT-4', callback_data: 'chat_gpt4' }
    ],
    [
      { text: 'üîÆ ChatGPT-4 Vision', callback_data: 'chat_vision' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üìä –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const userStates = new Map<number, {
  state: string;
  service: string;
  data?: any;
}>();

// üöÄ –ö–û–ú–ê–ù–î–ê /start
bot.command("start", async (ctx) => {
  console.log("üì® /start from user:", ctx.from?.id);
  
  try {
    const userId = ctx.from?.id;
    if (!userId) return;

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
    await prisma.user.upsert({
      where: { telegramId: userId },
      update: { 
        username: ctx.from?.username || "",
        firstName: ctx.from?.first_name || "",
        lastName: ctx.from?.last_name || ""
      },
      create: {
        telegramId: userId,
        username: ctx.from?.username || "",
        firstName: ctx.from?.first_name || "",
        lastName: ctx.from?.last_name || "",
        tokens: 50 // –°—Ç–∞—Ä—Ç–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã
      }
    });

    const welcomeMessage = `üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ AICEX AI!

ü§ñ **–î–æ—Å—Ç—É–ø–Ω—ã–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏:**

üé® **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:**
‚Ä¢ Freepik AI - –±—ã—Å—Ç—Ä–æ –∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ
‚Ä¢ Midjourney - —Ö—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è

üé¨ **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ:**  
‚Ä¢ Freepik Video - –∫–æ—Ä–æ—Ç–∫–∏–µ —Ä–æ–ª–∏–∫–∏
‚Ä¢ Runway ML - –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –≤–∏–¥–µ–æ

üí¨ **AI –ß–∞—Ç:**
‚Ä¢ ChatGPT-4 - —É–º–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫
‚Ä¢ GPT-4 Vision - –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π

üåê **–í–µ–±-–≤–µ—Ä—Å–∏—è** - –ø–æ–ª–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª, –ø—Ä–æ—Ñ–∏–ª—å, —Ç–æ–∫–µ–Ω—ã

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`;

    await ctx.reply(welcomeMessage, {
      reply_markup: mainMenu
    });

    console.log("‚úÖ Welcome sent to user:", userId);

  } catch (error) {
    console.error("‚ùå Start error:", error);
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start –µ—â–µ —Ä–∞–∑.");
  }
});

// üîò –û–ë–†–ê–ë–û–¢–ö–ê CALLBACK –ö–ù–û–ü–û–ö
bot.on("callback_query", async (ctx) => {
  console.log("üîò Callback:", ctx.callbackQuery.data, "from:", ctx.from?.id);
  
  await ctx.answerCallbackQuery();
  
  const data = ctx.callbackQuery.data;
  const userId = ctx.from?.id;
  
  if (!userId) return;
  
  switch (data) {
    // üé® –ì–ï–ù–ï–†–ê–¶–ò–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
    case 'generate_image':
      await ctx.editMessageText(
        "üé® **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å:",
        { reply_markup: imageMenu }
      );
      break;

    case 'image_freepik':
      await ctx.editMessageText(
        "üé® **Freepik AI**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
        {
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'üåü Seedream v4', callback_data: 'freepik_seedream' },
                { text: '‚ö° Flux', callback_data: 'freepik_flux' }
              ],
              [
                { text: 'üîÆ Mystic', callback_data: 'freepik_mystic' }
              ],
              [
                { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_image' }
              ]
            ]
          }
        }
      );
      break;

    case 'image_midjourney':
      await ctx.editMessageText(
        "üñºÔ∏è **Midjourney**\n\nüöß –°–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω!\n\n–ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Freepik AI.",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_image' }]
            ]
          }
        }
      );
      break;

    // üé¨ –ì–ï–ù–ï–†–ê–¶–ò–Ø –í–ò–î–ï–û
    case 'generate_video':
      await ctx.editMessageText(
        "üé¨ **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å:",
        { reply_markup: videoMenu }
      );
      break;

    case 'video_freepik':
      userStates.set(userId, { state: 'waiting_video_prompt', service: 'freepik' });
      await ctx.editMessageText(
        "üé¨ **Freepik Video**\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å:\n\nüí° –ü—Ä–∏–º–µ—Ä: \"–ö–æ—Ç –∏–≥—Ä–∞–µ—Ç —Å –º—è—á–∏–∫–æ–º –≤ —Å–∞–¥—É\"",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_video' }]
            ]
          }
        }
      );
      break;

    case 'video_runway':
      userStates.set(userId, { state: 'waiting_video_prompt', service: 'runway' });
      await ctx.editMessageText(
        "üöÄ **Runway ML**\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å:\n\nüí° –ü—Ä–∏–º–µ—Ä: \"–õ–µ—Ç—è—â–∏–π –¥—Ä–æ–Ω –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º –Ω–∞ –∑–∞–∫–∞—Ç–µ\"",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_video' }]
            ]
          }
        }
      );
      break;

    // üí¨ AI –ß–ê–¢
    case 'chat_ai':
      await ctx.editMessageText(
        "üí¨ **AI –ß–∞—Ç**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
        { reply_markup: chatMenu }
      );
      break;

    case 'chat_gpt4':
      userStates.set(userId, { state: 'chatting', service: 'gpt4' });
      await ctx.editMessageText(
        "üß† **ChatGPT-4**\n\nüí¨ –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å –ª—é–±—ã–µ –≤–æ–ø—Ä–æ—Å—ã!\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–∏–∞–ª–æ–≥–∞.\n\nüõë –ù–∞–ø–∏—à–∏—Ç–µ \"—Å—Ç–æ–ø\" –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'chat_ai' }]
            ]
          }
        }
      );
      break;

    case 'chat_vision':
      userStates.set(userId, { state: 'vision_chat', service: 'gpt4_vision' });
      await ctx.editMessageText(
        "üîÆ **GPT-4 Vision**\n\nüì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!\n\nüí° –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ - —è –µ–≥–æ –æ–ø–∏—à—É.\n\nüõë –ù–∞–ø–∏—à–∏—Ç–µ \"—Å—Ç–æ–ø\" –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'chat_ai' }]
            ]
          }
        }
      );
      break;

    // üîô –ù–ê–í–ò–ì–ê–¶–ò–Ø
    case 'back_to_main':
      userStates.delete(userId); // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      await ctx.editMessageText(
        "üéØ **–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é**\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        { reply_markup: mainMenu }
      );
      break;

    default:
      console.log("‚ùì Unknown callback:", data);
  }
});

// üìù –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô
bot.on("message:text", async (ctx) => {
  const userId = ctx.from?.id;
  const text = ctx.message.text;
  
  if (!userId || !text) return;
  
  console.log("üìù Text message:", text, "from:", userId);
  
  const userState = userStates.get(userId);
  
  if (!userState) {
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await ctx.reply(
      "ü§ñ –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é.",
      { reply_markup: mainMenu }
    );
    return;
  }

  // –ö–æ–º–∞–Ω–¥–∞ "—Å—Ç–æ–ø" - –≤—ã—Ö–æ–¥ –∏–∑ –ª—é–±–æ–≥–æ —Ä–µ–∂–∏–º–∞
  if (text.toLowerCase() === '—Å—Ç–æ–ø' || text.toLowerCase() === 'stop') {
    userStates.delete(userId);
    await ctx.reply(
      "‚úÖ –î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
      { reply_markup: mainMenu }
    );
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è–º
  switch (userState.state) {
    case 'waiting_image_prompt':
      await handleImageGeneration(ctx, text, userState.service);
      break;
      
    case 'waiting_video_prompt':
      await handleVideoGeneration(ctx, text, userState.service);
      break;
      
    case 'chatting':
      await handleChatGPT(ctx, text);
      break;
      
    default:
      console.log("‚ùì Unknown state:", userState.state);
  }
});

// üì∏ –û–ë–†–ê–ë–û–¢–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô (–¥–ª—è GPT-4 Vision)
bot.on("message:photo", async (ctx) => {
  const userId = ctx.from?.id;
  if (!userId) return;
  
  console.log("üì∏ Photo from:", userId);
  
  const userState = userStates.get(userId);
  
  if (userState?.state === 'vision_chat') {
    await handleGPTVision(ctx);
  } else {
    await ctx.reply("üì∏ –î–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤—ã–±–µ—Ä–∏—Ç–µ 'GPT-4 Vision' –≤ –º–µ–Ω—é —á–∞—Ç–∞.");
  }
});

// üé® –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
async function handleImageGeneration(ctx: any, prompt: string, service: string) {
  const userId = ctx.from?.id;
  
  try {
    await ctx.reply("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...\n‚è±Ô∏è –≠—Ç–æ –∑–∞–π–º–µ—Ç 30-60 —Å–µ–∫—É–Ω–¥");
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    let result;
    
    if (service === 'freepik') {
      result = await aiManager.generateImage(prompt, 'freepik', userContext);
    } else if (service === 'dalle') {
      result = await aiManager.generateImage(prompt, 'dalle', userContext);
    } else {
      result = { success: false, error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å' };
    }
    
    if (result.success && result.data?.url) {
      await ctx.replyWithPhoto(result.data.url, {
        caption: `‚úÖ **–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ!**\n\nüìù –ü—Ä–æ–º–ø—Ç: "${prompt}"\nüé® –°–µ—Ä–≤–∏—Å: ${service === 'freepik' ? 'Freepik AI' : 'DALL-E'}\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}`,
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ –ï—â–µ –æ–¥–Ω–æ', callback_data: `image_${service}` },
              { text: 'üè† –ì–ª–∞–≤–Ω–∞—è', callback_data: 'back_to_main' }
            ]
          ]
        }
      });
    } else {
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${result.error}`);
    }
    
    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    userStates.delete(userId);
    
  } catch (error) {
    console.error("‚ùå Image generation error:", error);
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
    userStates.delete(userId);
  }
}

// üé¨ –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –í–ò–î–ï–û
async function handleVideoGeneration(ctx: any, prompt: string, service: string) {
  const userId = ctx.from?.id;
  
  try {
    await ctx.reply("üé¨ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –≤–∏–¥–µ–æ...\n‚è±Ô∏è –≠—Ç–æ –∑–∞–π–º–µ—Ç 2-5 –º–∏–Ω—É—Ç");
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    let result;
    
    if (service === 'freepik') {
      result = await aiManager.generateVideo(prompt, 'freepik', userContext);
    } else if (service === 'runway') {
      result = await aiManager.generateVideo(prompt, 'runway', userContext);
    } else {
      result = { success: false, error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å' };
    }
    
    if (result.success && result.data?.url) {
      await ctx.replyWithVideo(result.data.url, {
        caption: `‚úÖ **–í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!**\n\nüìù –ü—Ä–æ–º–ø—Ç: "${prompt}"\nüé¨ –°–µ—Ä–≤–∏—Å: ${service === 'freepik' ? 'Freepik Video' : 'Runway ML'}\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}`,
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ –ï—â–µ –æ–¥–Ω–æ', callback_data: `video_${service}` },
              { text: 'üè† –ì–ª–∞–≤–Ω–∞—è', callback_data: 'back_to_main' }
            ],
            // üé® –û–ë–†–ê–ë–û–¢–ö–ê –í–´–ë–û–†–ê –ú–û–î–ï–õ–ï–ô FREEPIK
            [
              { text: '‚ö° Flux', callback_data: 'freepik_flux' },
              { text: 'üîÆ Mystic', callback_data: 'freepik_mystic' },
              { text: 'üåü Seedream v4', callback_data: 'freepik_seedream' }
            ]
    case 'freepik_seedream':
      userStates.set(userId, { state: 'waiting_image_prompt', service: 'freepik', data: { model: 'seedream-v4' } });
      await ctx.editMessageText(
        "üåü **Seedream v4** - –ù–æ–≤–µ–π—à–∞—è –º–æ–¥–µ–ª—å Freepik\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\n\nüí° –ü—Ä–∏–º–µ—Ä: \"–ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º –≤ —Å—Ç–∏–ª–µ –∞–Ω–∏–º–µ\"",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ö –º–æ–¥–µ–ª—è–º', callback_data: 'image_freepik' }]
            ]
          }
        }
  const userId = ctx.from?.id;
  
  try {
    await ctx.reply("üß† –î—É–º–∞—é...");
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —á–∞—Ç–∞
    const messages: ChatMessage[] = [
      { role: 'user', content: message }
    ];
    
    const result = await aiManager.chatWithAI(messages, 'gpt4', userContext);
    
    if (result.success && result.data?.content) {
      await ctx.reply(
        `üß† **ChatGPT-4:**\n\n${result.data.content}\n\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}\n\nüí¨ –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –¥–∏–∞–ª–æ–≥ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ "—Å—Ç–æ–ø" –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.`
      );
    } else {
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ ChatGPT: ${result.error}`);
    }
    
  } catch (error) {
    console.error("‚ùå ChatGPT error:", error);
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ ChatGPT. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
  }
}

// üîÆ –§–£–ù–ö–¶–ò–Ø GPT-4 VISION
async function handleGPTVision(ctx: any) {
  const userId = ctx.from?.id;
  
  try {
    await ctx.reply("üîÆ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...");
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    // –ü–æ–ª—É—á–∞–µ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const photo = ctx.message.photo[ctx.message.photo.length - 1];
    const file = await ctx.api.getFile(photo.file_id);
    const imageUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
    
    // –ü–æ–ª—É—á–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ
    const prompt = ctx.message.caption || "–û–ø–∏—à–∏ –ø–æ–¥—Ä–æ–±–Ω–æ —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ –Ω–∞ —ç—Ç–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–µ";
    
    const result = await aiManager.analyzeImage(imageUrl, prompt, userContext);
    
    if (result.success && result.data?.content) {
      await ctx.reply(
        `üîÆ **GPT-4 Vision:**\n\n${result.data.content}\n\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}\n\nüì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ "—Å—Ç–æ–ø".`
      );
    } else {
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞: ${result.error}`);
    }
    
  } catch (error) {
    console.error("‚ùå Vision error:", error);
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
  }
}

// üìä –ó–ê–ü–£–°–ö –ë–û–¢–ê
export async function startProductionBot() {
  try {
    console.log("üöÄ Starting production bot...");
    
    const me = await bot.api.getMe();
    console.log("‚úÖ Bot info:", me);
    
    await bot.start();
    console.log("‚úÖ Production bot started successfully!");
    
  } catch (error) {
    console.error("‚ùå Failed to start production bot:", error);
    throw error;
  }
}

// Graceful shutdown
process.on("SIGINT", async () => {
  console.log("üõë Shutting down bot...");
  await bot.stop();
  await prisma.$disconnect();
  process.exit(0);
});

export { bot };
