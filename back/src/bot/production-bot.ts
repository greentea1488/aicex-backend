import { Bot } from "grammy";
import { logger } from "../utils/logger";
import { prisma } from "../utils/prismaClient";
import { AIServiceManager } from "../services/ai/AIServiceManager";
import { ChatMessage } from "../services/ai/OpenAIService";
import { FREEPIK_IMAGE_MODELS, FREEPIK_VIDEO_MODELS, getPopularImageModels, getPopularVideoModels, getImageModelById, getVideoModelById } from "../services/ai/FreepikModels";
import { UXHelpers } from "./utils/UXHelpers";
import { StateManager } from "./utils/StateManager";
import { TaskQueue } from "./utils/TaskQueue";
import { MidjourneyAPIService } from "../services/MidjourneyAPIService";

const bot = new Bot(process.env.BOT_TOKEN!);
const aiManager = new AIServiceManager();
const stateManager = new StateManager();
const taskQueue = new TaskQueue(stateManager);
const midjourneyService = new MidjourneyAPIService();

console.log("ü§ñ Starting AICEX Production Bot with enhanced UX...");

// üéØ –£–õ–£–ß–®–ï–ù–ù–û–ï –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ —Å –±—ã—Å—Ç—Ä—ã–º–∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏
function getMainMenu(userId?: number) {
  return UXHelpers.getSmartMainMenu(userId);
}

// üé® –ú–ï–ù–Æ –ì–ï–ù–ï–†–ê–¶–ò–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
const imageMenu = {
  inline_keyboard: [
    [
      { text: 'üé® Freepik AI', callback_data: 'image_freepik' },
      { text: 'üñºÔ∏è Midjourney', callback_data: 'image_midjourney' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üé¨ –ú–ï–ù–Æ –ì–ï–ù–ï–†–ê–¶–ò–ò –í–ò–î–ï–û  
const videoMenu = {
  inline_keyboard: [
    [
      { text: 'üé¨ Freepik Video', callback_data: 'video_freepik' }
    ],
    [
      { text: '‚ö° Kling AI', callback_data: 'video_kling' },
      { text: 'üöÄ Runway ML', callback_data: 'video_runway' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üí¨ –ú–ï–ù–Æ –ß–ê–¢–ê
const chatMenu = {
  inline_keyboard: [
    [
      { text: 'üß† ChatGPT-4', callback_data: 'chat_gpt4' }
    ],
    [
      { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
    ]
  ]
};

// üé® –ú–ï–ù–Æ –ú–û–î–ï–õ–ï–ô FREEPIK - –ü–û–ü–£–õ–Ø–†–ù–´–ï
function getFreepikImageModelsMenu() {
  const popularModels = getPopularImageModels();
  
  return {
    inline_keyboard: [
      [
        { text: 'üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ', callback_data: 'freepik_popular_images' },
        { text: 'üìã –í—Å–µ –º–æ–¥–µ–ª–∏', callback_data: 'freepik_all_images' }
      ],
      ...popularModels.slice(0, 4).map(model => ([
        { 
          text: `${model.isNew ? 'üÜï ' : ''}${model.name}`, 
          callback_data: `freepik_img_${model.id}` 
        }
      ])),
      [
        { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_image' }
      ]
    ]
  };
}

// üé¨ –ú–ï–ù–Æ –ú–û–î–ï–õ–ï–ô FREEPIK - –í–ò–î–ï–û (–ë–ï–ó KLING)
function getFreepikVideoModelsMenu() {
  // –ò—Å–∫–ª—é—á–∞–µ–º Kling –º–æ–¥–µ–ª–∏ –∏–∑ Freepik –º–µ–Ω—é
  const nonKlingModels = FREEPIK_VIDEO_MODELS.filter(m => !m.id.includes('kling'));
  
  return {
    inline_keyboard: [
      [
        { text: 'üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ', callback_data: 'freepik_popular_videos' },
        { text: 'üìã –í—Å–µ –º–æ–¥–µ–ª–∏', callback_data: 'freepik_all_videos' }
      ],
      ...nonKlingModels.slice(0, 4).map(model => ([
        { 
          text: `${model.isNew ? 'üÜï ' : ''}${model.name}${model.resolution ? ` (${model.resolution})` : ''}`, 
          callback_data: `freepik_vid_${model.id}` 
        }
      ])),
      [
        { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_video' }
      ]
    ]
  };
}

// ‚ö° –ú–ï–ù–Æ KLING –ú–û–î–ï–õ–ï–ô (–∏—Å–ø–æ–ª—å–∑—É—é—Ç Freepik API)
function getKlingModelsMenu() {
  // –¢–æ–ª—å–∫–æ Kling –º–æ–¥–µ–ª–∏
  const klingModels = FREEPIK_VIDEO_MODELS.filter(m => m.id.includes('kling'));
  
  return {
    inline_keyboard: [
      [
        { text: 'üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ Kling', callback_data: 'kling_popular' },
        { text: 'üìã –í—Å–µ Kling –º–æ–¥–µ–ª–∏', callback_data: 'kling_all' }
      ],
      ...klingModels.slice(0, 4).map(model => ([
        { 
          text: `${model.isNew ? 'üÜï ' : ''}${model.name}`, 
          callback_data: `freepik_vid_${model.id}` // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ callback, —Ç.–∫. API –æ–¥–∏–Ω
        }
      ])),
      [
        { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_video' }
      ]
    ]
  };
}

// üìã –í–°–ï –ú–û–î–ï–õ–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
function getAllImageModelsMenu(page: number = 0) {
  const modelsPerPage = 6;
  const startIndex = page * modelsPerPage;
  const models = FREEPIK_IMAGE_MODELS.slice(startIndex, startIndex + modelsPerPage);
  
  const keyboard = models.map(model => ([
    { 
      text: `${model.isNew ? 'üÜï ' : ''}${model.name}`, 
      callback_data: `freepik_img_${model.id}` 
    }
  ]));
  
  // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
  const navButtons: Array<{ text: string; callback_data: string }> = [];
  if (page > 0) {
    navButtons.push({ text: '‚¨ÖÔ∏è –ü—Ä–µ–¥.', callback_data: `freepik_img_page_${page - 1}` });
  }
  if (startIndex + modelsPerPage < FREEPIK_IMAGE_MODELS.length) {
    navButtons.push({ text: '–°–ª–µ–¥. ‚û°Ô∏è', callback_data: `freepik_img_page_${page + 1}` });
  }
  
  if (navButtons.length > 0) {
    keyboard.push(navButtons);
  }
  
  keyboard.push([{ text: '‚¨ÖÔ∏è –ö –ø–æ–ø—É–ª—è—Ä–Ω—ã–º', callback_data: 'image_freepik' }]);
  
  return { inline_keyboard: keyboard };
}

// üìã –í–°–ï –ú–û–î–ï–õ–ò –í–ò–î–ï–û (–ë–ï–ó KLING)
function getAllVideoModelsMenu(page: number = 0) {
  const modelsPerPage = 6;
  const startIndex = page * modelsPerPage;
  // –ò—Å–∫–ª—é—á–∞–µ–º Kling –º–æ–¥–µ–ª–∏
  const nonKlingModels = FREEPIK_VIDEO_MODELS.filter(m => !m.id.includes('kling'));
  const models = nonKlingModels.slice(startIndex, startIndex + modelsPerPage);
  
  const keyboard = models.map(model => ([
    { 
      text: `${model.isNew ? 'üÜï ' : ''}${model.name}${model.resolution ? ` (${model.resolution})` : ''}`, 
      callback_data: `freepik_vid_${model.id}` 
    }
  ]));
  
  // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
  const navButtons: Array<{ text: string; callback_data: string }> = [];
  if (page > 0) {
    navButtons.push({ text: '‚¨ÖÔ∏è –ü—Ä–µ–¥.', callback_data: `freepik_vid_page_${page - 1}` });
  }
  if (startIndex + modelsPerPage < nonKlingModels.length) {
    navButtons.push({ text: '–°–ª–µ–¥. ‚û°Ô∏è', callback_data: `freepik_vid_page_${page + 1}` });
  }
  
  if (navButtons.length > 0) {
    keyboard.push(navButtons);
  }
  
  keyboard.push([{ text: '‚¨ÖÔ∏è –ö –ø–æ–ø—É–ª—è—Ä–Ω—ã–º', callback_data: 'video_freepik' }]);
  
  return { inline_keyboard: keyboard };
}

// üìã –í–°–ï –ú–û–î–ï–õ–ò KLING
function getAllKlingModelsMenu(page: number = 0) {
  const modelsPerPage = 6;
  const startIndex = page * modelsPerPage;
  const klingModels = FREEPIK_VIDEO_MODELS.filter(m => m.id.includes('kling'));
  const models = klingModels.slice(startIndex, startIndex + modelsPerPage);
  
  const keyboard = models.map(model => ([
    { 
      text: `${model.isNew ? 'üÜï ' : ''}${model.name}`, 
      callback_data: `freepik_vid_${model.id}` 
    }
  ]));
  
  // –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
  const navButtons: Array<{ text: string; callback_data: string }> = [];
  if (page > 0) {
    navButtons.push({ text: '‚¨ÖÔ∏è –ü—Ä–µ–¥.', callback_data: `kling_page_${page - 1}` });
  }
  if (startIndex + modelsPerPage < klingModels.length) {
    navButtons.push({ text: '–°–ª–µ–¥. ‚û°Ô∏è', callback_data: `kling_page_${page + 1}` });
  }
  
  if (navButtons.length > 0) {
    keyboard.push(navButtons);
  }
  
  keyboard.push([{ text: '‚¨ÖÔ∏è –ö –ø–æ–ø—É–ª—è—Ä–Ω—ã–º', callback_data: 'video_kling' }]);
  
  return { inline_keyboard: keyboard };
}

// üìä –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const userStates = new Map<number, {
  state: string;
  service: string;
  data?: any;
}>();

// üöÄ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ö–û–ú–ê–ù–î–ê /start
bot.command("start", async (ctx) => {
  console.log("üì® /start from user:", ctx.from?.id);
  
  try {
    const userId = ctx.from?.id;
    if (!userId) return;

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
    await prisma.user.upsert({
      where: { telegramId: userId },
      update: { 
        username: ctx.from?.username || "",
        firstName: ctx.from?.first_name || "",
        lastName: ctx.from?.last_name || ""
      },
      create: {
        telegramId: userId,
        username: ctx.from?.username || "",
        firstName: ctx.from?.first_name || "",
        lastName: ctx.from?.last_name || "",
        tokens: 50 // –°—Ç–∞—Ä—Ç–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const recommendations = await UXHelpers.getUserRecommendations(userId);
    const stats = await UXHelpers.getUserStats(userId);

    let welcomeMessage = `üéâ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ AICEX AI!</b>\n\n`;
    
    if (stats && stats.totalGenerations > 0) {
      welcomeMessage += `üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –£ –≤–∞—Å ${stats.totalGenerations} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π\n`;
      welcomeMessage += `üí∞ –¢–æ–∫–µ–Ω–æ–≤: ${stats.currentBalance}\n\n`;
    } else {
      welcomeMessage += `üéÅ <b>–°—Ç–∞—Ä—Ç–æ–≤—ã–π –±–æ–Ω—É—Å:</b> 50 —Ç–æ–∫–µ–Ω–æ–≤\n`;
      welcomeMessage += `üöÄ <b>27 AI –º–æ–¥–µ–ª–µ–π</b> –≤ –æ–¥–Ω–æ–º –±–æ—Ç–µ\n\n`;
    }

    welcomeMessage += `üéØ <b>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç:</b>\n`;
    welcomeMessage += `‚Ä¢ üé® –ë—ã—Å—Ç—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ - –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è\n`;
    welcomeMessage += `‚Ä¢ üí¨ AI –ß–∞—Ç - –æ–±—â–µ–Ω–∏–µ —Å ChatGPT-4\n`;
    welcomeMessage += `‚Ä¢ üé¨ –í–∏–¥–µ–æ - —Å–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞\n\n`;

    if (recommendations.length > 0) {
      welcomeMessage += `üí° <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</b>\n`;
      recommendations.forEach(rec => {
        welcomeMessage += `‚Ä¢ ${rec.message}\n`;
      });
      welcomeMessage += `\n`;
    }

    welcomeMessage += `–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`;

    await ctx.reply(welcomeMessage, {
      reply_markup: getMainMenu(userId),
      parse_mode: "HTML"
    });

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    UXHelpers.setUserState(userId, {
      currentPath: ['main'],
      currentAction: null
    });

    console.log("‚úÖ Enhanced welcome sent to user:", userId);

  } catch (error) {
    console.error("‚ùå Start error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
});

// üîò –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê CALLBACK –ö–ù–û–ü–û–ö
bot.on("callback_query", async (ctx) => {
  console.log("üîò Callback:", ctx.callbackQuery.data, "from:", ctx.from?.id);
  
  await ctx.answerCallbackQuery();
  
  const data = ctx.callbackQuery.data;
  const userId = ctx.from?.id;
  
  if (!userId) return;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const userState = UXHelpers.getUserState(userId);
  const breadcrumb = UXHelpers.getBreadcrumb(userState?.currentPath || ['main']);
  
  try {
  switch (data) {
      // üéØ –ù–û–í–´–ï –ë–´–°–¢–†–´–ï –î–ï–ô–°–¢–í–ò–Ø
      case 'quick_image':
        await handleQuickImage(ctx, userId);
        break;
        
      case 'quick_chat':
        await handleQuickChat(ctx, userId);
        break;
        
      case 'midjourney_menu':
        await handleMidjourneyMenu(ctx, userId);
        break;
        
      case 'stats':
        await handleStats(ctx, userId);
        break;
        
      case 'back_to_main':
        await handleBackToMain(ctx, userId);
        break;
        
      case 'stop_action':
        await handleStopAction(ctx, userId);
        break;
        
      case 'retry_last_action':
        await handleRetryLastAction(ctx, userId);
        break;
        
      case 'cancel_retry':
        await handleCancelRetry(ctx, userId);
        break;

      // üñºÔ∏è MIDJOURNEY –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò
      case 'midjourney_7.0':
        await handleMidjourneyGeneration(ctx, userId, '7.0');
        break;
        
      case 'midjourney_6.1':
        await handleMidjourneyGeneration(ctx, userId, '6.1');
        break;
        
      case 'midjourney_quick':
        await handleMidjourneyQuick(ctx, userId);
        break;

    // üé® –ì–ï–ù–ï–†–ê–¶–ò–Ø –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
    case 'generate_image':
      await ctx.editMessageText(
        "üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å:",
        { reply_markup: imageMenu, parse_mode: "HTML" }
      );
      break;

    case 'image_freepik':
      await ctx.editMessageText(
        "üé® <b>Freepik AI</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
        { reply_markup: getFreepikImageModelsMenu(), parse_mode: "HTML" }
      );
      break;

    case 'freepik_all_images':
      await ctx.editMessageText(
        "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Freepik</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
        { reply_markup: getAllImageModelsMenu(0), parse_mode: "HTML" }
      );
      break;


    case 'image_midjourney':
      await ctx.editMessageText(
        "üñºÔ∏è <b>Midjourney</b>\n\nüöß –°–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω!\n\n–ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Freepik AI.",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_image' }]
            ]
          },
          parse_mode: "HTML"
        }
      );
      break;

    // üé¨ –ì–ï–ù–ï–†–ê–¶–ò–Ø –í–ò–î–ï–û
    case 'generate_video':
      await ctx.editMessageText(
        "üé¨ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å:",
        { reply_markup: videoMenu, parse_mode: "HTML" }
      );
      break;

    case 'video_freepik':
      await ctx.editMessageText(
        "üé¨ <b>Freepik Video</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:",
        { reply_markup: getFreepikVideoModelsMenu(), parse_mode: "HTML" }
      );
      break;

    case 'video_kling':
      await ctx.editMessageText(
        "‚ö° <b>Kling AI Video</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å Kling –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ:\n\nüí° –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Freepik API",
        { reply_markup: getKlingModelsMenu(), parse_mode: "HTML" }
      );
      break;

    case 'kling_all':
      await ctx.editMessageText(
        "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ Kling AI</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
        { reply_markup: getAllKlingModelsMenu(0), parse_mode: "HTML" }
      );
      break;

    case 'freepik_all_videos':
      await ctx.editMessageText(
        "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ –≤–∏–¥–µ–æ Freepik</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
        { reply_markup: getAllVideoModelsMenu(0), parse_mode: "HTML" }
      );
      break;

    case 'video_runway':
      userStates.set(userId, { state: 'waiting_video_prompt', service: 'runway' });
      await ctx.editMessageText(
        "üöÄ <b>Runway ML</b>\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∫–æ—Ç–æ—Ä–æ–µ —Ö–æ—Ç–∏—Ç–µ —Å–æ–∑–¥–∞—Ç—å:\n\nüí° –ü—Ä–∏–º–µ—Ä: \"–õ–µ—Ç—è—â–∏–π –¥—Ä–æ–Ω –Ω–∞–¥ –≥–æ—Ä–æ–¥–æ–º –Ω–∞ –∑–∞–∫–∞—Ç–µ\"",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'generate_video' }]
            ]
          },
          parse_mode: "HTML"
        }
      );
      break;

    // üí¨ AI –ß–ê–¢
    case 'chat_ai':
      await ctx.editMessageText(
        "üí¨ <b>AI –ß–∞—Ç</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
        { reply_markup: chatMenu, parse_mode: "HTML" }
      );
      break;

    case 'chat_gpt4':
      userStates.set(userId, { state: 'chatting', service: 'gpt4' });
      await ctx.editMessageText(
        "üß† <b>ChatGPT-4</b>\n\nüí¨ –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å –ª—é–±—ã–µ –≤–æ–ø—Ä–æ—Å—ã!\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–∏–∞–ª–æ–≥–∞.\n\nüõë –ù–∞–ø–∏—à–∏—Ç–µ \"—Å—Ç–æ–ø\" –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.",
        {
          reply_markup: {
            inline_keyboard: [
              [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'chat_ai' }]
            ]
          },
          parse_mode: "HTML"
        }
      );
      break;


    // üîô –ù–ê–í–ò–ì–ê–¶–ò–Ø
    case 'back_to_main':
      userStates.delete(userId); // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      try {
        await ctx.editMessageText(
          "üéØ <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
          { reply_markup: getMainMenu(userId), parse_mode: "HTML" }
        );
      } catch (error) {
        // –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
        await ctx.reply(
          "üéØ <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
          { reply_markup: getMainMenu(userId), parse_mode: "HTML" }
        );
      }
      break;

    default:
      // üé® –û–ë–†–ê–ë–û–¢–ö–ê –ë–´–°–¢–†–´–• –î–ï–ô–°–¢–í–ò–ô –° –¢–ï–ö–°–¢–û–ú
      if (data?.startsWith('quick_img_')) {
        const prompt = data.replace('quick_img_', '');
        UXHelpers.setUserState(userId, {
          currentAction: 'waiting_image_prompt',
          data: { service: 'freepik', model: 'seedream' }
        });
        await handleImageGeneration(ctx, prompt, 'freepik', { model: 'seedream' });
        break;
      }
      
      if (data?.startsWith('quality_img_')) {
        const prompt = data.replace('quality_img_', '');
        UXHelpers.setUserState(userId, {
          currentAction: 'waiting_image_prompt',
          data: { service: 'freepik', model: 'flux-pro' }
        });
        await handleImageGeneration(ctx, prompt, 'freepik', { model: 'flux-pro' });
        break;
      }
      
      // üé® –û–ë–†–ê–ë–û–¢–ö–ê –í–´–ë–û–†–ê –ú–û–î–ï–õ–ï–ô –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
      if (data?.startsWith('freepik_img_')) {
        const modelId = data.replace('freepik_img_', '');
        const model = getImageModelById(modelId);
        
        if (model) {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º UXHelpers –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
          UXHelpers.setUserState(userId, { 
            currentAction: 'waiting_image_prompt', 
            data: { service: 'freepik', model: modelId, endpoint: model.endpoint } 
          });
          
          await ctx.editMessageText(
            `${model.isNew ? 'üÜï ' : ''}<b>${model.name}</b>\n\n${model.description}\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\n\nüí° –ü—Ä–∏–º–µ—Ä: "–∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"`,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '‚¨ÖÔ∏è –ö –º–æ–¥–µ–ª—è–º', callback_data: 'image_freepik' }]
                ]
              },
              parse_mode: "HTML"
            }
          );
        }
      }
      // üé¨ –û–ë–†–ê–ë–û–¢–ö–ê –í–´–ë–û–†–ê –ú–û–î–ï–õ–ï–ô –í–ò–î–ï–û
      else if (data?.startsWith('freepik_vid_')) {
        const modelId = data.replace('freepik_vid_', '');
        const model = getVideoModelById(modelId);
        
        if (model) {
          userStates.set(userId, { 
            state: 'waiting_video_prompt', 
            service: 'freepik', 
            data: { model: modelId, endpoint: model.endpoint } 
          });
          
          await ctx.editMessageText(
            `${model.isNew ? 'üÜï ' : ''}<b>${model.name}</b>${model.resolution ? ` (${model.resolution})` : ''}\n\n${model.description}\n\nüìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–µ–æ:\n\nüí° –ü—Ä–∏–º–µ—Ä: "–∫–æ—Ç –∏–≥—Ä–∞–µ—Ç —Å –º—è—á–∏–∫–æ–º"`,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: '‚¨ÖÔ∏è –ö –º–æ–¥–µ–ª—è–º', callback_data: 'video_freepik' }]
                ]
              },
              parse_mode: "HTML"
            }
          );
        }
      }
      // üìÑ –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –°–¢–†–ê–ù–ò–¶–ê–ú –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
      else if (data?.startsWith('freepik_img_page_')) {
        const page = parseInt(data.replace('freepik_img_page_', ''));
        await ctx.editMessageText(
          "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π Freepik</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
          { reply_markup: getAllImageModelsMenu(page), parse_mode: "HTML" }
        );
      }
      // üìÑ –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –°–¢–†–ê–ù–ò–¶–ê–ú –í–ò–î–ï–û
      else if (data?.startsWith('freepik_vid_page_')) {
        const page = parseInt(data.replace('freepik_vid_page_', ''));
        await ctx.editMessageText(
          "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ –≤–∏–¥–µ–æ Freepik</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
          { reply_markup: getAllVideoModelsMenu(page), parse_mode: "HTML" }
        );
      }
      // üìÑ –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –°–¢–†–ê–ù–ò–¶–ê–ú KLING
      else if (data?.startsWith('kling_page_')) {
        const page = parseInt(data.replace('kling_page_', ''));
        await ctx.editMessageText(
          "üìã <b>–í—Å–µ –º–æ–¥–µ–ª–∏ Kling AI</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:",
          { reply_markup: getAllKlingModelsMenu(page), parse_mode: "HTML" }
        );
      }
      else {
        console.log("‚ùì Unknown callback:", data);
        await ctx.reply("‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞—á–∞–ª–∞.");
      }
    }
  } catch (error) {
    console.error("‚ùå Callback error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
});

// üìù –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô
bot.on("message:text", async (ctx) => {
  const userId = ctx.from?.id;
  const text = ctx.message.text;
  
  if (!userId || !text) return;
  
  console.log("üìù Text message:", text, "from:", userId);
  
  try {
    // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userState = UXHelpers.getUserState(userId);
  
  if (!userState) {
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    await ctx.reply(
        `ü§ñ –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é.\n\n${UXHelpers.getBreadcrumb(['main'])}`,
        { reply_markup: getMainMenu(userId) }
    );
    return;
  }

  // –ö–æ–º–∞–Ω–¥–∞ "—Å—Ç–æ–ø" - –≤—ã—Ö–æ–¥ –∏–∑ –ª—é–±–æ–≥–æ —Ä–µ–∂–∏–º–∞
  if (text.toLowerCase() === '—Å—Ç–æ–ø' || text.toLowerCase() === 'stop') {
      UXHelpers.clearUserState(userId);
      stateManager.endSession(userId.toString());
    await ctx.reply(
      "‚úÖ –î–∏–∞–ª–æ–≥ –∑–∞–≤–µ—Ä—à–µ–Ω.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        { reply_markup: getMainMenu(userId) }
    );
    return;
  }

    // –ö–æ–º–∞–Ω–¥–∞ "–ø–æ–º–æ—â—å" - –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å
    if (text.toLowerCase() === '–ø–æ–º–æ—â—å' || text.toLowerCase() === 'help') {
      await showHelp(ctx, userId);
      return;
    }

    // –ö–æ–º–∞–Ω–¥–∞ "—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞" - –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    if (text.toLowerCase() === '—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞' || text.toLowerCase() === 'stats') {
      await handleStats(ctx, userId);
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è–º
    switch (userState.currentAction) {
    case 'waiting_image_prompt':
        await handleImageGeneration(ctx, text, userState.data?.service || 'freepik', userState.data);
      break;
      
    case 'waiting_video_prompt':
        await handleVideoGeneration(ctx, text, userState.data?.service || 'freepik', userState.data);
      break;
      
      case 'waiting_midjourney_prompt':
        await handleMidjourneyTextInput(ctx, text, userState.data?.model || '7.0');
        break;
        
      case 'waiting_chat_message':
    case 'chatting':
      await handleChatGPT(ctx, text);
      break;
      
    default:
        // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–∏–ª —Ç–µ–∫—Å—Ç –±–µ–∑ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        // –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º –±—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        await handleQuickTextInput(ctx, userId, text);
    }
    
  } catch (error) {
    console.error("‚ùå Text message error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
});

// üéØ –û–±—Ä–∞–±–æ—Ç–∫–∞ –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
async function handleQuickTextInput(ctx: any, userId: number, text: string) {
  // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –ø–æ—Ö–æ–∂ –Ω–∞ –ø—Ä–æ–º–ø—Ç –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–±–æ–ª–µ–µ —É–º–Ω–∞—è –ª–æ–≥–∏–∫–∞)
  const imageKeywords = ['–∑–∞–∫–∞—Ç', '—Ä–∞—Å—Å–≤–µ—Ç', '–ø–µ–π–∑–∞–∂', '–ø–æ—Ä—Ç—Ä–µ—Ç', '–∫–æ—à–∫–∞', '—Å–æ–±–∞–∫–∞', '–¥–æ–º', '–≥–æ—Ä–æ–¥', '–º–æ—Ä–µ', '–≥–æ—Ä—ã', '–ª–µ—Å', '—Ü–≤–µ—Ç—ã', '–∫—Ä–∞—Å–∏–≤—ã–π', '–∫—Ä–∞—Å–∏–≤–∞—è', '–∫—Ä–∞—Å–∏–≤–æ–µ', '—Ñ–∞–Ω—Ç–∞—Å—Ç–∏—á–µ—Å–∫–∏–π', '—Ñ–∞–Ω—Ç–∞—Å—Ç–∏—á–µ—Å–∫–∞—è', '–∫–æ—Å–º–æ—Å', '–∑–≤–µ–∑–¥—ã', '–ª—É–Ω–∞', '—Å–æ–ª–Ω—Ü–µ', '–Ω–µ–±–æ', '–æ–±–ª–∞–∫–∞'];
  const hasImageKeywords = imageKeywords.some(keyword => text.toLowerCase().includes(keyword));
  
  if (text.length > 5 && (text.includes('–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ') || text.includes('–∫–∞—Ä—Ç–∏–Ω–∫–∞') || text.includes('—Ñ–æ—Ç–æ') || hasImageKeywords)) {
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ —Å—Ä–∞–∑—É –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    UXHelpers.setUserState(userId, {
      currentAction: 'waiting_image_prompt',
      data: { service: 'freepik', model: 'seedream' }
    });
    
    // –°—Ä–∞–∑—É –∑–∞–ø—É—Å–∫–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
    await handleImageGeneration(ctx, text, 'freepik', { model: 'seedream' });
    return;
  }
  
  // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –ø–æ—Ö–æ–∂ –Ω–∞ –ø—Ä–æ–º–ø—Ç –¥–ª—è –≤–∏–¥–µ–æ
  if (text.length > 15 && (text.includes('–≤–∏–¥–µ–æ') || text.includes('–∞–Ω–∏–º–∞—Ü–∏—è') || text.includes('–¥–≤–∏–∂–µ–Ω–∏–µ'))) {
    await ctx.reply(
      `üé¨ <b>–ë—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ</b>\n\n–ü—Ä–æ–º–ø—Ç: "${text}"\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–∏—Å:`,
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              { text: '‚ö° Kling AI', callback_data: `quick_vid_kling_${text}` },
              { text: 'üöÄ Runway ML', callback_data: `quick_vid_runway_${text}` }
            ],
            [{ text: 'üìã –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã', callback_data: 'generate_video' }]
          ]
        }
      }
    );
    return;
  }
  
  // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º —á–∞—Ç
          await ctx.reply(
            `üí¨ <b>AI –ß–∞—Ç</b>\n\n–ü—Ä–æ–º–ø—Ç: "${text}"\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:`,
            {
              parse_mode: "HTML",
              reply_markup: {
                inline_keyboard: [
                  [
                    { text: 'üß† ChatGPT-4', callback_data: `quick_chat_gpt_${text}` }
                  ],
                  [{ text: 'üìã –í—Å–µ –º–æ–¥–µ–ª–∏', callback_data: 'chat_ai' }]
                ]
              }
            }
          );
}

// üìñ –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å
async function showHelp(ctx: any, userId: number) {
  const message = `üìñ <b>–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞</b>\n\n` +
    `üéØ <b>–ë—ã—Å—Ç—Ä—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n` +
    `‚Ä¢ "—Å—Ç–æ–ø" - –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ\n` +
    `‚Ä¢ "–ø–æ–º–æ—â—å" - –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n` +
    `‚Ä¢ "—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞" - –ø–æ–∫–∞–∑–∞—Ç—å –≤–∞—à—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n\n` +
    `üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:</b>\n` +
    `–ü—Ä–æ—Å—Ç–æ –æ–ø–∏—à–∏—Ç–µ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–≤–∏–¥–µ—Ç—å\n` +
    `<i>–ü—Ä–∏–º–µ—Ä: "–∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"</i>\n\n` +
    `üé¨ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ:</b>\n` +
    `–û–ø–∏—à–∏—Ç–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∏–ª–∏ —Å—Ü–µ–Ω—É\n` +
    `<i>–ü—Ä–∏–º–µ—Ä: "–∫–æ—Ç –∏–≥—Ä–∞–µ—Ç —Å –º—è—á–∏–∫–æ–º"</i>\n\n` +
    `üí¨ <b>AI –ß–∞—Ç:</b>\n` +
    `–ó–∞–¥–∞–≤–∞–π—Ç–µ –ª—é–±—ã–µ –≤–æ–ø—Ä–æ—Å—ã\n` +
    `<i>–ü—Ä–∏–º–µ—Ä: "–†–∞—Å—Å–∫–∞–∂–∏ –∞–Ω–µ–∫–¥–æ—Ç"</i>\n\n` +
    `üì∏ <b>–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:</b>\n` +
    `–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\n\n` +
    `üí∞ <b>–¢–æ–∫–µ–Ω—ã:</b>\n` +
    `‚Ä¢ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: 5-15 —Ç–æ–∫–µ–Ω–æ–≤\n` +
    `‚Ä¢ –í–∏–¥–µ–æ: 20-50 —Ç–æ–∫–µ–Ω–æ–≤\n` +
    `‚Ä¢ –ß–∞—Ç: 1-3 —Ç–æ–∫–µ–Ω–∞\n\n` +
    `üí° <b>–°–æ–≤–µ—Ç—ã:</b>\n` +
    `‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –¥–ª—è –ª—É—á—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤\n` +
    `‚Ä¢ –ë—É–¥—å—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã –≤ –æ–ø–∏—Å–∞–Ω–∏—è—Ö\n` +
    `‚Ä¢ –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤\n` +
    `‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –≤—Ä–µ–º–µ–Ω–∏`;
  
  const keyboard = {
    inline_keyboard: [
      [
        { text: 'üé® –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', callback_data: 'quick_image' },
        { text: 'üí¨ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —á–∞—Ç', callback_data: 'quick_chat' }
      ],
      [
        { text: 'üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' },
        { text: '‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'back_to_main' }
      ]
    ]
  };
  
  await ctx.reply(message, {
    parse_mode: "HTML",
    reply_markup: keyboard
  });
}


// üé® –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
async function handleImageGeneration(ctx: any, prompt: string, service: string, data?: any) {
  const userId = ctx.from?.id;
  const startTime = Date.now();
  
  try {
    // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –≤ –æ—á–µ—Ä–µ–¥–∏
    const task = stateManager.createTask(userId, 'image', service, prompt, data);
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞
    const createProgressBar = (percent: number, width: number = 10): string => {
      const filled = Math.round((percent / 100) * width);
      const empty = width - filled;
      return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
    };
    
    // –û–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º (–±—É–¥–µ–º –µ–≥–æ –æ–±–Ω–æ–≤–ª—è—Ç—å)
    const progressMsg = await ctx.reply(`‚è≥ <b>–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...</b>\n\n${createProgressBar(10)} 10%`, { parse_mode: 'HTML' });
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
    try {
      await ctx.api.editMessageText(
        progressMsg.chat.id,
        progressMsg.message_id,
        `üé® <b>–ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...</b>\n\n${createProgressBar(30)} 30%`,
        { parse_mode: 'HTML' }
      );
    } catch (e) {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
    }
    
    console.log('==================== HANDLE IMAGE GENERATION START ====================');
    console.log('Service:', service);
    console.log('Prompt:', prompt);
    console.log('Data:', JSON.stringify(data, null, 2));
    console.log('User Context:', JSON.stringify(userContext, null, 2));
    console.log('===============================================================');
    
    let result;
    
    if (service === 'freepik') {
      const freepikOptions = {
        model: data?.model || 'seedream',
        aspect_ratio: '1:1'
      };
      
      console.log('==================== FREEPIK GENERATION OPTIONS ====================');
      console.log('Options:', JSON.stringify(freepikOptions, null, 2));
      console.log('===============================================================');
      
      result = await aiManager.generateImage(prompt, 'freepik', userContext, freepikOptions);
    } else if (service === 'dalle') {
      result = await aiManager.generateImage(prompt, 'dalle', userContext);
    } else {
      result = { success: false, error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å' };
    }
    
    console.log('==================== HANDLE IMAGE GENERATION RESULT ====================');
    console.log('Result:', JSON.stringify(result, null, 2));
    console.log('===============================================================');
    
    const duration = Math.floor((Date.now() - startTime) / 1000);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
    try {
      await ctx.api.editMessageText(
        progressMsg.chat.id,
        progressMsg.message_id,
        `‚úÖ <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ!</b>\n\n${createProgressBar(100)} 100%`,
        { parse_mode: 'HTML' }
      );
    } catch (e) {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É
    }
    
    // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
    await new Promise(resolve => setTimeout(resolve, 500));
    
    if (result.success && result.data?.url) {
      logger.info('Image generation completed:', {
        service,
        data,
        dataModel: data?.model,
        resultMetadata: result.data?.metadata
      });
      
      const modelText = data?.model ? ` (${data.model})` : '';
      await ctx.replyWithPhoto(result.data.url, {
        caption: `‚úÖ <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ!</b>\n\nüìù –ü—Ä–æ–º–ø—Ç: "${prompt}"\nüé® –°–µ—Ä–≤–∏—Å: ${service === 'freepik' ? 'Freepik AI' + modelText : 'DALL-E'}\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}\n‚è±Ô∏è –í—Ä–µ–º—è: ${UXHelpers.formatTime(duration)}`,
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ –ï—â–µ –æ–¥–Ω–æ', callback_data: 'quick_image' },
              { text: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' }
            ],
            [{ text: 'üè† –ì–ª–∞–≤–Ω–∞—è', callback_data: 'back_to_main' }]
          ]
        }
      });
      
    } else {
      await UXHelpers.sendSmartErrorNotification(ctx, result.error);
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–¥–∞—á–∏
    stateManager.updateTask(task.id, {
      status: result.success ? 'completed' : 'failed',
      result: result.data,
      error: result.error,
      completedAt: new Date()
    });
    
    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    UXHelpers.clearUserState(userId);
    
  } catch (error) {
    console.error("‚ùå Image generation error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
    UXHelpers.clearUserState(userId);
  }
}

// üé¨ –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –í–ò–î–ï–û
async function handleVideoGeneration(ctx: any, prompt: string, service: string, data?: any) {
  const userId = ctx.from?.id;
  const startTime = Date.now();
  
  try {
    // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –≤ –æ—á–µ—Ä–µ–¥–∏
    const task = stateManager.createTask(userId, 'video', service, prompt, data);
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
    await UXHelpers.showProgress(ctx, {
      stage: '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏',
      progress: 5,
      estimatedTime: 180,
      message: '–ü—Ä–æ–≤–µ—Ä—è—é –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤...'
    });
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    await UXHelpers.showProgress(ctx, {
      stage: '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–∏–¥–µ–æ',
      progress: 20,
      estimatedTime: 160,
      message: '–û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –≤ AI —Å–µ—Ä–≤–∏—Å...'
    });
    
    let result;
    
    if (service === 'freepik') {
      result = await aiManager.generateVideo(prompt, 'freepik', userContext, data);
    } else if (service === 'runway') {
      result = await aiManager.generateVideo(prompt, 'runway', userContext, data);
    } else {
      result = { success: false, error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å' };
    }
    
    const duration = Math.floor((Date.now() - startTime) / 1000);
    
    if (result.success && result.data?.url) {
      await UXHelpers.showProgress(ctx, {
        stage: '–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ',
        progress: 100,
        estimatedTime: 0,
        message: '–í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!'
      });
      
      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const serviceName = service === 'freepik' ? 'Freepik Video' : 'Runway ML';
      await ctx.replyWithVideo(result.data.url, {
        caption: `‚úÖ <b>–í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!</b>\n\nüìù –ü—Ä–æ–º–ø—Ç: "${prompt}"\nüé¨ –°–µ—Ä–≤–∏—Å: ${serviceName}\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}\n‚è±Ô∏è –í—Ä–µ–º—è: ${UXHelpers.formatTime(duration)}`,
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ –ï—â–µ –æ–¥–Ω–æ', callback_data: 'generate_video' },
              { text: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' }
            ],
            [{ text: 'üè† –ì–ª–∞–≤–Ω–∞—è', callback_data: 'back_to_main' }]
          ]
        }
      });
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
      await UXHelpers.sendSuccessNotification(ctx, {
        tokensUsed: result.tokensUsed,
        service: serviceName,
        duration,
        repeatAction: 'generate_video'
      });
      
    } else {
      await UXHelpers.sendSmartErrorNotification(ctx, result.error);
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–¥–∞—á–∏
    stateManager.updateTask(task.id, {
      status: result.success ? 'completed' : 'failed',
      result: result.data,
      error: result.error,
      completedAt: new Date()
    });
    
    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    UXHelpers.clearUserState(userId);
    
  } catch (error) {
    console.error("‚ùå Video generation error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
    UXHelpers.clearUserState(userId);
  }
}

// üí¨ –§–£–ù–ö–¶–ò–Ø –ß–ê–¢–ê –° CHATGPT
async function handleChatGPT(ctx: any, message: string) {
  const userId = ctx.from?.id;
  
  try {
    await ctx.reply("üß† –î—É–º–∞—é...");
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userBalance = await aiManager.getUserBalance(userId);
    const userContext = { telegramId: userId, currentTokens: userBalance };
    
    // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —á–∞—Ç–∞
    const messages: ChatMessage[] = [
      { role: 'user', content: message }
    ];
    
    const result = await aiManager.chatWithAI(messages, 'gpt4', userContext);
    
    if (result.success && result.data?.content) {
      await ctx.reply(
        `üß† <b>ChatGPT-4:</b>\n\n${result.data.content}\n\nüí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${result.tokensUsed}\n\nüí¨ –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –¥–∏–∞–ª–æ–≥ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ "—Å—Ç–æ–ø" –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.`,
        { parse_mode: "HTML" }
      );
    } else {
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ ChatGPT: ${result.error}`);
    }
    
  } catch (error) {
    console.error("‚ùå ChatGPT error:", error);
    await ctx.reply("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ ChatGPT. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.");
  }
}


// üéØ –ù–û–í–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –î–ï–ô–°–¢–í–ò–ô

// üé® –ë—ã—Å—Ç—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
async function handleQuickImage(ctx: any, userId: number) {
  try {
    UXHelpers.updateUserPath(userId, 'quick_image');
    
    // –ù–ï —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–æ–¥–µ–ª—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - –ø—É—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±–µ—Ä–µ—Ç
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–µ—Ç —Ç–µ–∫—Å—Ç, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –º–æ–¥–µ–ª—å –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤—ã–±–æ—Ä–∞
    
    const message = `üé® <b>–ë—ã—Å—Ç—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</b>\n\n` +
      `–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:\n\n` +
      `üí° <b>–°–æ–≤–µ—Ç:</b> Seedream –±—ã—Å—Ç—Ä–µ–µ, Flux Pro –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üî• Seedream v3 (–±—ã—Å—Ç—Ä–æ)', callback_data: 'freepik_img_seedream' },
          { text: '‚ö° Flux Pro (–∫–∞—á–µ—Å—Ç–≤–æ)', callback_data: 'freepik_img_flux-pro' }
        ],
        [
          { text: 'üìã –í—Å–µ –º–æ–¥–µ–ª–∏', callback_data: 'image_freepik' },
          { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
        ]
      ]
    };
    
    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: keyboard
    });
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üí¨ –ë—ã—Å—Ç—Ä—ã–π —á–∞—Ç
async function handleQuickChat(ctx: any, userId: number) {
  try {
    UXHelpers.updateUserPath(userId, 'quick_chat');
    
    const message = `üí¨ <b>AI –ß–∞—Ç</b>\n\n` +
      `–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–ª–∏ —Å—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–∏–∞–ª–æ–≥–∞:\n\n` +
      `üí° <b>–ü—Ä–∏–º–µ—Ä:</b> "–†–∞—Å—Å–∫–∞–∂–∏ –∞–Ω–µ–∫–¥–æ—Ç"`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üß† ChatGPT-4', callback_data: 'chat_gpt4' }
        ],
        [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }]
      ]
    };
    
    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: keyboard
    });
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
    UXHelpers.setUserState(userId, {
      currentAction: 'waiting_chat_message',
      data: { service: 'gpt4' }
    });
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üñºÔ∏è Midjourney Menu
async function handleMidjourneyMenu(ctx: any, userId: number) {
  try {
    UXHelpers.updateUserPath(userId, 'midjourney');

    if (!midjourneyService.isConfigured()) {
      await ctx.editMessageText(
        `üñºÔ∏è <b>Midjourney</b>\n\n` +
        `‚ùå –°–µ—Ä–≤–∏—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.\n` +
        `–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.`,
        {
          parse_mode: "HTML",
          reply_markup: UXHelpers.getBackButton('back_to_main')
        }
      );
      return;
    }

    const models = midjourneyService.getAvailableModels();
    const popularModels = models.slice(0, 4); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –º–æ–¥–µ–ª–∏

    let message = `üñºÔ∏è <b>Midjourney - –ü—Ä–µ–º–∏—É–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—è</b>\n\n` +
      `üéØ –°–∞–º–∞—è –º–æ—â–Ω–∞—è –Ω–µ–π—Ä–æ—Å–µ—Ç—å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π!\n` +
      `‚ú® –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫\n\n` +
      `üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> 7-8 —Ç–æ–∫–µ–Ω–æ–≤ –∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n\n` +
      `–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üî• Midjourney 7.0', callback_data: 'midjourney_7.0' },
          { text: '‚ö° Midjourney 6.1', callback_data: 'midjourney_6.1' }
        ],
        [
          { text: 'üìã –í—Å–µ –º–æ–¥–µ–ª–∏', callback_data: 'midjourney_all_models' },
          { text: 'üé® –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç', callback_data: 'midjourney_quick' }
        ],
        [
          { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
        ]
      ]
    };

    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: keyboard
    });

  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üñºÔ∏è Midjourney Generation
async function handleMidjourneyGeneration(ctx: any, userId: number, model: string) {
  try {
    UXHelpers.setUserState(userId, {
      currentAction: 'waiting_midjourney_prompt',
      data: { model }
    });

    const modelInfo = midjourneyService.getAvailableModels().find(m => m.id === model);
    const cost = modelInfo?.cost || 8;

    const message = `üñºÔ∏è <b>Midjourney ${model}</b>\n\n` +
      `üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: ${cost} —Ç–æ–∫–µ–Ω–æ–≤\n` +
      `üéØ –ú–æ–¥–µ–ª—å: ${modelInfo?.name || `Midjourney ${model}`}\n\n` +
      `üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\n\n` +
      `üí° <b>–ü—Ä–∏–º–µ—Ä:</b> "–∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º –≤ —Å—Ç–∏–ª–µ —Ñ—ç–Ω—Ç–µ–∑–∏"`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º', callback_data: 'midjourney_menu' },
          { text: 'üé® –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç', callback_data: 'midjourney_quick' }
        ]
      ]
    };

    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: keyboard
    });

  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üñºÔ∏è Midjourney Quick Start
async function handleMidjourneyQuick(ctx: any, userId: number) {
  try {
    UXHelpers.setUserState(userId, {
      currentAction: 'waiting_midjourney_prompt',
      data: { model: '7.0' } // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–∞–º—É—é –Ω–æ–≤—É—é –º–æ–¥–µ–ª—å
    });

    const message = `üé® <b>Midjourney - –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç</b>\n\n` +
      `üöÄ –ú–æ–¥–µ–ª—å: Midjourney 7.0 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)\n` +
      `üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: 8 —Ç–æ–∫–µ–Ω–æ–≤\n\n` +
      `üìù –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:\n\n` +
      `üí° <b>–ü—Ä–∏–º–µ—Ä—ã:</b>\n` +
      `‚Ä¢ "–∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–∫–∞—Ç –Ω–∞–¥ –æ–∫–µ–∞–Ω–æ–º"\n` +
      `‚Ä¢ "—Ñ—É—Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –≥–æ—Ä–æ–¥ –≤ —Å—Ç–∏–ª–µ –∫–∏–±–µ—Ä–ø–∞–Ω–∫"\n` +
      `‚Ä¢ "–º–∏–ª–∞—è –∫–æ—à–∫–∞ –≤ –∫–æ—Å–º–æ—Å–µ"`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –º–æ–¥–µ–ª—è–º', callback_data: 'midjourney_menu' },
          { text: '‚öôÔ∏è –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å', callback_data: 'midjourney_all_models' }
        ]
      ]
    };

    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: keyboard
    });

  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üñºÔ∏è Midjourney Text Input Handler
async function handleMidjourneyTextInput(ctx: any, text: string, model: string) {
  const userId = ctx.from?.id;
  const startTime = Date.now();

  try {
    // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –≤ –æ—á–µ—Ä–µ–¥–∏
    const task = stateManager.createTask(userId, 'image', 'midjourney', text, { model });

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
    await UXHelpers.showProgress(ctx, {
      stage: '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏',
      progress: 10,
      estimatedTime: 90,
      message: '–ü—Ä–æ–≤–µ—Ä—è—é –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤...'
    });

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { telegramId: userId }
    });

    if (!user) {
      throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å
    const modelInfo = midjourneyService.getAvailableModels().find(m => m.id === model);
    const cost = modelInfo?.cost || 8;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
    if (user.tokens < cost) {
      throw new Error(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤. –¢—Ä–µ–±—É–µ—Ç—Å—è: ${cost}, –¥–æ—Å—Ç—É–ø–Ω–æ: ${user.tokens}`);
    }

    await UXHelpers.showProgress(ctx, {
      stage: '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è',
      progress: 30,
      estimatedTime: 70,
      message: '–û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –≤ Midjourney —á–µ—Ä–µ–∑ Gen API...'
    });

    // –í—ã–∑—ã–≤–∞–µ–º Midjourney API
    const result = await midjourneyService.generateImage({
      prompt: text,
      model,
      userId: parseInt(user.id),
      telegramId: userId
    });

    const duration = Math.floor((Date.now() - startTime) / 1000);

    if (result.success && result.taskId) {
      await UXHelpers.showProgress(ctx, {
        stage: '–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ',
        progress: 100,
        estimatedTime: 0,
        message: '–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ!'
      });

      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
      await new Promise(resolve => setTimeout(resolve, 1000));

      const message = `‚úÖ <b>–ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ!</b>\n\n` +
        `üìù –ü—Ä–æ–º–ø—Ç: "${text}"\n` +
        `üñºÔ∏è –ú–æ–¥–µ–ª—å: Midjourney ${model}\n` +
        `üí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${cost}\n` +
        `‚è±Ô∏è –í—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è: ${UXHelpers.formatTime(duration)}\n\n` +
        `‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–π–º–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ 1-2 –º–∏–Ω—É—Ç—ã.\n` +
        `üîÑ –°—Ç–∞—Ç—É—Å –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.`;

      await ctx.reply(message, {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ –ï—â–µ –æ–¥–Ω–æ', callback_data: 'midjourney_quick' },
              { text: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' }
            ],
            [{ text: 'üè† –ì–ª–∞–≤–Ω–∞—è', callback_data: 'back_to_main' }]
          ]
        }
      });

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
      await UXHelpers.sendSuccessNotification(ctx, {
        tokensUsed: cost,
        service: `Midjourney ${model}`,
        duration,
        repeatAction: 'midjourney_quick'
      });

    } else {
      throw new Error(result.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–¥–∞—á–∏
    stateManager.updateTask(task.id, {
      status: result.success ? 'processing' : 'failed',
      result: result.taskId,
      error: result.error,
      completedAt: new Date()
    });

    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
    UXHelpers.clearUserState(userId);

  } catch (error) {
    console.error("‚ùå Midjourney generation error:", error);
    await UXHelpers.sendSmartErrorNotification(ctx, error);
    UXHelpers.clearUserState(userId);
  }
}

// üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
async function handleStats(ctx: any, userId: number) {
  try {
    UXHelpers.updateUserPath(userId, 'stats');
    
    const stats = await UXHelpers.getUserStats(userId);
    const queueStats = taskQueue.getQueueStats();
    
    logger.info('Stats retrieved:', { 
      userId, 
      stats, 
      queueStats,
      hasStats: !!stats
    });
    
    let message = `üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n\n`;
    
    if (stats) {
      message += `üë§ <b>–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n` +
        `üéØ –ì–µ–Ω–µ—Ä–∞—Ü–∏–π: ${stats.totalGenerations}\n` +
        `üí∞ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤: ${stats.tokensSpent}\n` +
        `üíé –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: ${stats.currentBalance}\n` +
        `üèÜ –õ—é–±–∏–º—ã–π —Å–µ—Ä–≤–∏—Å: ${stats.favoriteService}\n\n`;
    } else {
      logger.warn('No stats found for user:', userId);
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    const systemStats = await prisma.generationHistory.groupBy({
      by: ['status'],
      _count: { status: true }
    });
    
    const completedCount = systemStats.find(s => s.status === 'completed')?._count.status || 0;
    const failedCount = systemStats.find(s => s.status === 'failed')?._count.status || 0;
    const processingCount = systemStats.find(s => s.status === 'processing')?._count.status || 0;
    
    message += `üåê <b>–°–∏—Å—Ç–µ–º–∞:</b>\n` +
      `‚è≥ –í –æ—á–µ—Ä–µ–¥–∏: ${queueStats.pending}\n` +
      `üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è: ${processingCount}\n` +
      `‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: ${completedCount}\n` +
      `‚ùå –û—à–∏–±–æ–∫: ${failedCount}`;
    
    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîÑ –û–±–Ω–æ–≤–∏—Ç—å', callback_data: 'stats' },
          { text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'back_to_main' }
        ]
      ]
    };
    
    // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    // –ò–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
    try {
      await ctx.editMessageText(message, {
        parse_mode: "HTML",
        reply_markup: keyboard
      });
    } catch (e) {
      // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ —Ñ–æ—Ç–æ), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      await ctx.reply(message, {
        parse_mode: "HTML",
        reply_markup: keyboard
      });
    }
    
    // –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å "—á–∞—Å–∏–∫–∏"
    await ctx.answerCallbackQuery();
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// ‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
async function handleBackToMain(ctx: any, userId: number) {
  try {
    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    UXHelpers.clearUserState(userId);
    stateManager.endSession(userId.toString());
    
    const message = `üè† <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:`;
    
    // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    // –ò–Ω–∞—á–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
    try {
      await ctx.editMessageText(message, {
        parse_mode: "HTML",
        reply_markup: getMainMenu(userId)
      });
    } catch (e) {
      // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ —Ñ–æ—Ç–æ), –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      await ctx.reply(message, {
        parse_mode: "HTML",
        reply_markup: getMainMenu(userId)
      });
    }
    
    // –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å "—á–∞—Å–∏–∫–∏"
    await ctx.answerCallbackQuery();
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ
async function handleStopAction(ctx: any, userId: number) {
  try {
    // –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    stateManager.cancelUserTasks(userId);
    
    const message = `üõë <b>–î–µ–π—Å—Ç–≤–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ</b>\n\n–í—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏ –æ—Ç–º–µ–Ω–µ–Ω—ã.`;
    
    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: UXHelpers.getBackButton('back_to_main')
    });
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ
async function handleRetryLastAction(ctx: any, userId: number) {
  try {
    const repeatContext = stateManager.getRepeatContext(userId);
    
    if (repeatContext.task) {
      await taskQueue.retryTask(repeatContext.task.id);
      
      const message = `üîÑ <b>–ü–æ–≤—Ç–æ—Ä –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω</b>\n\n–ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.`;
      
      await ctx.editMessageText(message, {
        parse_mode: "HTML",
        reply_markup: UXHelpers.getBackButton('back_to_main')
      });
    } else {
      await ctx.reply("‚ùå –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞.");
    }
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// ‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–≤—Ç–æ—Ä
async function handleCancelRetry(ctx: any, userId: number) {
  try {
    const userTasks = taskQueue.getUserTasks(userId);
    const pendingTasks = userTasks.filter(task => task.status === 'pending');
    
    for (const task of pendingTasks) {
      await taskQueue.cancelTask(task.id);
    }
    
    const message = `‚ùå <b>–ü–æ–≤—Ç–æ—Ä –æ—Ç–º–µ–Ω–µ–Ω</b>\n\n–í—Å–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–≤—Ç–æ—Ä—ã –æ—Ç–º–µ–Ω–µ–Ω—ã.`;
    
    await ctx.editMessageText(message, {
      parse_mode: "HTML",
      reply_markup: UXHelpers.getBackButton('back_to_main')
    });
    
  } catch (error) {
    await UXHelpers.sendSmartErrorNotification(ctx, error);
  }
}

// üìä –ó–ê–ü–£–°–ö –ë–û–¢–ê
export async function startProductionBot() {
  try {
    console.log("üöÄ Starting production bot...");
    
    const me = await bot.api.getMe();
    console.log("‚úÖ Bot info:", me);
    
    await bot.start();
    console.log("‚úÖ Production bot started successfully!");
    
  } catch (error) {
    console.error("‚ùå Failed to start production bot:", error);
    throw error;
  }
}

// Graceful shutdown
process.on("SIGINT", async () => {
  console.log("üõë Shutting down bot...");
  await bot.stop();
  await prisma.$disconnect();
  process.exit(0);
});

export { bot };

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–ø—É—Å–∫–∞ —Å –∞–ª–∏–∞—Å–æ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
export { startProductionBot as startBot };

// –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é (–Ω–µ —á–µ—Ä–µ–∑ import)
if (require.main === module) {
  startProductionBot().catch(console.error);
}
