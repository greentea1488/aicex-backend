import { Bot } from "grammy";
import { startMenu, aiHandler, universalControlKeyboard, helpKeyboard, settingsKeyboard, backToMainMenu } from "./keyboards/startKeyboard";
import { FreepikHandler } from "./handlers/freepikHandler";
import { RunwayHandler } from "./handlers/runwayHandler";
import { ChatGPTHandler } from "./handlers/chatgptHandler";
import { MidjourneyHandler } from "./handlers/midjourneyHandler";
import { SessionManager } from "./services/SessionManager";
import { SecurityService } from "../services/SecurityService";
import { FreepikRouter } from "./routers/FreepikRouter";
import { RunwayRouter } from "./routers/RunwayRouter";
import { ChatGPTRouter } from "./routers/ChatGPTRouter";
import { MidjourneyRouter } from "./routers/MidjourneyRouter";
import { logger } from "../utils/logger";
import { prisma } from "../utils/prismaClient";

// –°–æ–∑–¥–∞–µ–º –±–æ—Ç–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–µ–Ω
let bot: Bot | null = null;
if (process.env.BOT_TOKEN) {
  bot = new Bot(process.env.BOT_TOKEN);
} else {
  logger.warn("BOT_TOKEN not provided, bot functionality will be disabled");
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –±–æ—Ç–∞ –¥–ª—è webhook
export { bot };

const sessionManager = new SessionManager();
const securityService = new SecurityService();

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è handlers
const freepikHandler = new FreepikHandler();
const runwayHandler = new RunwayHandler(sessionManager);
const chatgptHandler = new ChatGPTHandler(sessionManager);
const midjourneyHandler = new MidjourneyHandler(sessionManager);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è routers
const freepikRouter = new FreepikRouter(freepikHandler);
const runwayRouter = new RunwayRouter(runwayHandler);
const chatgptRouter = new ChatGPTRouter(chatgptHandler);
const midjourneyRouter = new MidjourneyRouter(midjourneyHandler);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±–æ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω
if (bot) {
  // üöÄ –ì–õ–ê–í–ù–´–ï –ú–ï–ù–Æ AI –°–ï–†–í–ò–°–û–í
  bot.callbackQuery("chatgpt", async ctx => {
  await ctx.answerCallbackQuery();
  await chatgptHandler.showMainMenu(ctx);
});

bot.callbackQuery("midjourney", async ctx => {
  await ctx.answerCallbackQuery();
  await midjourneyHandler.showMainMenu(ctx);
});

bot.callbackQuery("freepik", async ctx => {
  await ctx.answerCallbackQuery();
  await freepikHandler.showMainMenu(ctx);
});

bot.callbackQuery("runway", async ctx => {
  await ctx.answerCallbackQuery();
  await runwayHandler.showMainMenu(ctx);
});

bot.callbackQuery("kling", async ctx => {
  await ctx.answerCallbackQuery();
  await aiHandler.handleAISelection(ctx, "kling");
});

// –ü–æ–º–æ—â—å –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
bot.callbackQuery("help", async ctx => {
  await ctx.answerCallbackQuery();
  await ctx.reply(
    "üÜò –ü–æ–º–æ—â—å\n\n" + 
    "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ AI —Å–µ—Ä–≤–∏—Å –∏–∑ –º–µ–Ω—é\n" + 
    "‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –Ω–∞—á–∞–ª–∞ –¥–∏–∞–ª–æ–≥–∞\n" + 
    "‚Ä¢ –ù–∞–ø–∏—à–∏—Ç–µ 'STOP' –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\n" + 
    "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ inline –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏",
    { reply_markup: helpKeyboard }
  );
});

bot.callbackQuery("knowledge", async ctx => {
  await ctx.answerCallbackQuery();
  await ctx.reply("üìö –ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è!");
});

bot.callbackQuery("settings", async ctx => {
  await ctx.answerCallbackQuery();
  await ctx.reply(
    "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏\n\n" + 
    "‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ AI —Å–µ—Ä–≤–∏—Å –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n" + 
    "‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏\n" + 
    "‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è",
    { reply_markup: settingsKeyboard }
  );
});

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
bot.callbackQuery("back_to_start", async ctx => {
  await ctx.answerCallbackQuery();
  await ctx.reply("ü§ñ **AICEX AI Bot** - –í—ã–±–µ—Ä–∏—Ç–µ AI —Å–µ—Ä–≤–∏—Å:", {
    parse_mode: 'Markdown',
    reply_markup: startMenu
  });
});

// üéØ –ï–î–ò–ù–´–ô CALLBACK ROUTER
bot.on("callback_query:data", async ctx => {
  await ctx.answerCallbackQuery();
  
  const data = ctx.callbackQuery.data;
  if (!data) return;
  
  logger.info(`üîò Callback received: "${data}" from user ${ctx.from?.id}`);
  
  // –ü–æ–ø—ã—Ç–∫–∞ –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ AI routers
  let handled = false;
  
  try {
    // Freepik router
    if (data.startsWith("freepik_")) {
      logger.info(`üé® Routing to Freepik router: ${data}`);
      handled = await freepikRouter.handleCallback(ctx);
    }
    // Runway router  
    else if (data.startsWith("runway_")) {
      logger.info(`üöÄ Routing to Runway router: ${data}`);
      handled = await runwayRouter.handleCallback(ctx);
    }
    // ChatGPT router
    else if (data.startsWith("chatgpt_")) {
      logger.info(`ü§ñ Routing to ChatGPT router: ${data}`);
      handled = await chatgptRouter.handleCallback(ctx);
    }
    // Midjourney router
    else if (data.startsWith("midjourney_")) {
      logger.info(`üñºÔ∏è Routing to Midjourney router: ${data}`);
      handled = await midjourneyRouter.handleCallback(ctx);
    }
    
    // –ï—Å–ª–∏ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ - –ª–æ–≥–∏—Ä—É–µ–º
    if (!handled) {
      logger.warn(`‚ö†Ô∏è Unhandled callback: ${data} - no router matched`);
    } else {
      logger.info(`‚úÖ Callback handled successfully: ${data}`);
    }
  } catch (error) {
    logger.error(`‚ùå Error handling callback ${data}:`, error);
    await ctx.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã");
  }
});

// üñºÔ∏è –û–ë–†–ê–ë–û–¢–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô –î–õ–Ø CHATGPT
bot.on("message:photo", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  logger.info(`üì∏ Photo received from user ${userId}`);

  const session = sessionManager.getSession(userId);
  logger.info(`üîç Session check for photo: ${session ? `active (${session.aiProvider})` : 'none'}`);
  
  if (session && session.aiProvider === 'chatgpt_vision') {
    logger.info(`‚úÖ ChatGPT Vision session active, processing image...`);
    try {
      const photo = ctx.message.photo[ctx.message.photo.length - 1];
      const file = await ctx.api.getFile(photo.file_id);
      const imageUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
      
      logger.info(`üì• Image downloaded: ${imageUrl}`);
      
      const prompt = ctx.message.caption || "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –æ–ø–∏—à–∏ —á—Ç–æ –Ω–∞ –Ω–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ";
      logger.info(`üìù Image analysis prompt: ${prompt}`);
      
      // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–∞
      const validation = securityService.validatePrompt(prompt);
      if (!validation.valid) {
        logger.warn(`‚ùå Prompt validation failed: ${validation.error}`);
        await ctx.reply(`‚ùå ${validation.error}`);
        return;
      }
      
      await ctx.reply("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...");
      logger.info(`ü§ñ Calling ChatGPT Vision API...`);
      
      const chatgptService = new (await import("./services/ai/ChatGPTService")).ChatGPTService();
      const result = await chatgptService.analyzeImage(imageUrl, prompt);
      
      logger.info(`‚úÖ ChatGPT Vision analysis completed, length: ${result.content.length}`);
      
      await ctx.reply(`üì∏ **–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è GPT-4V:**\n\n${result.content}`);
      
    } catch (error: any) {
      logger.error("‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${error.message}`);
    }
    return;
  }
});

// üìÑ –û–ë–†–ê–ë–û–¢–ö–ê –î–û–ö–£–ú–ï–ù–¢–û–í –î–õ–Ø CHATGPT
bot.on("message:document", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  logger.info(`üìÑ Document received from user ${userId}`);

  const session = sessionManager.getSession(userId);
  logger.info(`üîç Session check for document: ${session ? `active (${session.aiProvider})` : 'none'}`);
  
  if (session && session.aiProvider === 'chatgpt_document') {
    logger.info(`‚úÖ ChatGPT Document session active, processing...`);
    try {
      const document = ctx.message.document;
      const fileName = document.file_name || 'document';
      const fileSize = document.file_size || 0;
      
      logger.info(`üìã Document info: name=${fileName}, size=${fileSize} bytes, mime=${document.mime_type}`);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (–º–∞–∫—Å 20 –ú–ë)
      const maxSize = 20 * 1024 * 1024;
      if (fileSize > maxSize) {
        logger.warn(`‚ùå Document too large: ${fileSize} > ${maxSize}`);
        await ctx.reply("‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 20 –ú–ë");
        return;
      }

      await ctx.reply("üìÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –¥–æ–∫—É–º–µ–Ω—Ç...");

      // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
      logger.info(`üì• Downloading document...`);
      const { FileHandler } = await import("../utils/fileHandler");
      const fileHandler = new FileHandler();
      const { filePath, buffer } = await fileHandler.downloadFile(document.file_id);
      logger.info(`‚úÖ Document downloaded to: ${filePath}`);

      try {
        // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ —Ñ–∞–π–ª–∞
        logger.info(`üìù Extracting text from document...`);
        const fileContent = await fileHandler.extractText(filePath, document.mime_type);
        logger.info(`‚úÖ Text extracted, length: ${fileContent.length} chars`);
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (–º–∞–∫—Å 15000 —Å–∏–º–≤–æ–ª–æ–≤)
        const maxContentLength = 15000;
        const truncatedContent = fileContent.length > maxContentLength 
          ? fileContent.substring(0, maxContentLength) + "\n\n[... —Ç–µ–∫—Å—Ç –æ–±—Ä–µ–∑–∞–Ω ...]"
          : fileContent;

        const prompt = ctx.message.caption || "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –∏ –¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ";
        logger.info(`üìù Analysis prompt: ${prompt}`);

        // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–∞
        const validation = securityService.validatePrompt(prompt);
        if (!validation.valid) {
          logger.warn(`‚ùå Prompt validation failed: ${validation.error}`);
          await ctx.reply(`‚ùå ${validation.error}`);
          fileHandler.cleanupFile(filePath);
          return;
        }

        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ñ–∞–π–ª —Å –ø–æ–º–æ—â—å—é ChatGPT
        logger.info(`ü§ñ Calling ChatGPT for file analysis...`);
        const chatgptService = new (await import("./services/ai/ChatGPTService")).ChatGPTService();
        const result = await chatgptService.analyzeFile(truncatedContent, fileName, prompt, userId);
        
        logger.info(`‚úÖ ChatGPT analysis completed, length: ${result.content.length}`);

        await ctx.reply(
          `üìÑ **–ê–Ω–∞–ª–∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ "${fileName}":**\n\n${result.content}`,
          { parse_mode: 'Markdown' }
        );

        // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        fileHandler.cleanupFile(filePath);
        logger.info(`üóëÔ∏è Temporary file cleaned up`);

      } catch (error: any) {
        fileHandler.cleanupFile(filePath);
        throw error;
      }

    } catch (error: any) {
      logger.error("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞: ${error.message}`);
    }
    return;
  } else {
    logger.info(`‚ÑπÔ∏è Document received but no chatgpt_document session active`);
  }
});

// üé§ –û–ë–†–ê–ë–û–¢–ö–ê –ê–£–î–ò–û –§–ê–ô–õ–û–í –î–õ–Ø CHATGPT
bot.on("message:audio", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  logger.info(`üé§ Audio received from user ${userId}`);

  const session = sessionManager.getSession(userId);
  logger.info(`üîç Session check for audio: ${session ? `active (${session.aiProvider})` : 'none'}`);
  
  if (session && session.aiProvider === 'chatgpt_audio') {
    logger.info(`‚úÖ ChatGPT Audio session active, transcribing...`);
    try {
      const audio = ctx.message.audio;
      const fileName = audio.file_name || 'audio';
      const fileSize = audio.file_size || 0;
      
      logger.info(`üéµ Audio info: name=${fileName}, size=${fileSize} bytes, mime=${audio.mime_type}`);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (–º–∞–∫—Å 25 –ú–ë –¥–ª—è Whisper)
      const maxSize = 25 * 1024 * 1024;
      if (fileSize > maxSize) {
        logger.warn(`‚ùå Audio too large: ${fileSize} > ${maxSize}`);
        await ctx.reply("‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –∞—É–¥–∏–æ: 25 –ú–ë");
        return;
      }

      await ctx.reply("üé§ –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é –∞—É–¥–∏–æ...");

      // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
      logger.info(`üì• Downloading audio...`);
      const { FileHandler } = await import("../utils/fileHandler");
      const fileHandler = new FileHandler();
      const { filePath } = await fileHandler.downloadFile(audio.file_id);
      logger.info(`‚úÖ Audio downloaded to: ${filePath}`);

      try {
        // –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ–º –∞—É–¥–∏–æ —Å –ø–æ–º–æ—â—å—é Whisper
        logger.info(`üéôÔ∏è Calling Whisper API for transcription...`);
        const chatgptService = new (await import("./services/ai/ChatGPTService")).ChatGPTService();
        const result = await chatgptService.transcribeAudio(filePath);
        
        logger.info(`‚úÖ Whisper transcription completed, length: ${result.content.length}`);

        await ctx.reply(
          `üé§ **–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è –∞—É–¥–∏–æ "${fileName}":**\n\n${result.content}`,
          { parse_mode: 'Markdown' }
        );

        // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        fileHandler.cleanupFile(filePath);
        logger.info(`üóëÔ∏è Audio file cleaned up`);

      } catch (error: any) {
        fileHandler.cleanupFile(filePath);
        throw error;
      }

    } catch (error: any) {
      logger.error("‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ –∞—É–¥–∏–æ:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ –∞—É–¥–∏–æ: ${error.message}`);
    }
    return;
  } else {
    logger.info(`‚ÑπÔ∏è Audio received but no chatgpt_audio session active`);
  }
});

// üéôÔ∏è –û–ë–†–ê–ë–û–¢–ö–ê –ì–û–õ–û–°–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô –î–õ–Ø CHATGPT
bot.on("message:voice", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  logger.info(`üéôÔ∏è Voice message received from user ${userId}`);

  const session = sessionManager.getSession(userId);
  logger.info(`üîç Session check for voice: ${session ? `active (${session.aiProvider})` : 'none'}`);
  
  if (session && session.aiProvider === 'chatgpt_audio') {
    logger.info(`‚úÖ ChatGPT Audio session active, transcribing voice...`);
    try {
      const voice = ctx.message.voice;
      const fileSize = voice.file_size || 0;
      const duration = voice.duration || 0;
      
      logger.info(`üéôÔ∏è Voice info: duration=${duration}s, size=${fileSize} bytes, mime=${voice.mime_type}`);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (–º–∞–∫—Å 25 –ú–ë –¥–ª—è Whisper)
      const maxSize = 25 * 1024 * 1024;
      if (fileSize > maxSize) {
        logger.warn(`‚ùå Voice too large: ${fileSize} > ${maxSize}`);
        await ctx.reply("‚ùå –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 25 –ú–ë");
        return;
      }

      await ctx.reply("üéôÔ∏è –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É—é –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...");

      // –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
      logger.info(`üì• Downloading voice message...`);
      const { FileHandler } = await import("../utils/fileHandler");
      const fileHandler = new FileHandler();
      const { filePath } = await fileHandler.downloadFile(voice.file_id);
      logger.info(`‚úÖ Voice downloaded to: ${filePath}`);

      try {
        // –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Whisper
        logger.info(`üéôÔ∏è Calling Whisper API for voice transcription...`);
        const chatgptService = new (await import("./services/ai/ChatGPTService")).ChatGPTService();
        const result = await chatgptService.transcribeAudio(filePath);
        
        logger.info(`‚úÖ Voice transcription completed, length: ${result.content.length}`);

        await ctx.reply(
          `üéôÔ∏è **–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:**\n\n${result.content}`,
          { parse_mode: 'Markdown' }
        );

        // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        fileHandler.cleanupFile(filePath);
        logger.info(`üóëÔ∏è Voice file cleaned up`);

      } catch (error: any) {
        fileHandler.cleanupFile(filePath);
        throw error;
      }

    } catch (error: any) {
      logger.error("‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: ${error.message}`);
    }
    return;
  } else {
    logger.info(`‚ÑπÔ∏è Voice received but no chatgpt_audio session active`);
  }
});

// üí¨ –û–ë–†–ê–ë–û–¢–ö–ê –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô
bot.on("message:text", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const imageSession = sessionManager.getSession(userId);
  
  // ChatGPT –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
  if (imageSession && imageSession.aiProvider === 'chatgpt_image') {
    try {
      const prompt = ctx.message.text;
      
      // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–∞
      const validation = securityService.validatePrompt(prompt);
      if (!validation.valid) {
        await ctx.reply(`‚ùå ${validation.error}`);
        return;
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ rate limit
      const rateLimitOk = await securityService.checkRateLimit(ctx.from!.id, 'image_generation');
      if (!rateLimitOk) {
        await ctx.reply("‚è∞ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –º–∏–Ω—É—Ç—É.");
        return;
      }
      
      await ctx.reply("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...");
      
      const imageUrl = await chatgptHandler.generateImage(prompt, userId);
      
      if (imageUrl.startsWith('http')) {
        await ctx.replyWithPhoto(imageUrl, { 
          caption: `üñºÔ∏è **DALL-E —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ:**\n\nüìù –ü—Ä–æ–º–ø—Ç: ${prompt}` 
        });
      } else {
        await ctx.reply(imageUrl); // –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
      }
      
    } catch (error: any) {
      logger.error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${error.message}`);
    }
    return;
  }

  // Midjourney –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
  if (imageSession && imageSession.aiProvider === 'midjourney_generate') {
    try {
      const prompt = ctx.message.text;
      
      // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–æ–º–ø—Ç–∞
      const validation = securityService.validatePrompt(prompt);
      if (!validation.valid) {
        await ctx.reply(`‚ùå ${validation.error}`);
        return;
      }
      
      await ctx.reply("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Midjourney...");
      
      await midjourneyHandler.startGeneration(ctx, prompt);
      
    } catch (error: any) {
      logger.error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ Midjourney:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${error.message}`);
    }
    return;
  }

  // –û–±—ã—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –¥—Ä—É–≥–∏—Ö AI
  if (aiHandler.hasActiveSession(userId)) {
    // –≠—Ç–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è aiHandler
    return;
  }
});

// üé¨ –û–ë–†–ê–ë–û–¢–ö–ê –í–ò–î–ï–û
bot.on("message:video", async ctx => {
  const userId = ctx.from?.id.toString();
  if (!userId) return;

  const session = sessionManager.getSession(userId);
  if (session && session.aiProvider === 'runway') {
    try {
      const video = ctx.message.video;
      const file = await ctx.api.getFile(video.file_id);
      const videoUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
      
      await ctx.reply("üé¨ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ Runway...");
      
      // –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ
      await ctx.reply("üöß –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∏–¥–µ–æ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!");
      
    } catch (error: any) {
      logger.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ:", error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∏–¥–µ–æ: ${error.message}`);
    }
    return;
  }
});

// üöÄ –¢–ï–°–¢: –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
bot.on("message", async ctx => {
  logger.info(`üì® Message received: "${ctx.message.text}" from user ${ctx.from?.id} (@${ctx.from?.username})`);
  
  // –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –æ—Ç–≤–µ—Ç–∞
  if (ctx.message.text === "/start") {
    logger.info("üî• Detected /start command, sending simple reply...");
    try {
      await ctx.reply("‚úÖ –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç! Webhook –ø–æ–ª—É—á–µ–Ω –∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.");
      logger.info("‚úÖ Simple reply sent successfully");
    } catch (error) {
      logger.error("‚ùå Failed to send simple reply:", error);
    }
  }
});

// üöÄ START COMMAND
bot.command("start", async ctx => {
  const userId = ctx.from?.id;
  logger.info(`üì® /start command from user ${userId} (@${ctx.from?.username})`);
  
  if (!userId) {
    logger.error("No user ID in start command");
    return;
  }

  try {
    logger.info("Creating/updating user in database...");
    
    // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await prisma.user.upsert({
      where: { telegramId: userId },
      update: { 
        username: ctx.from?.username || undefined,
        firstName: ctx.from?.first_name || undefined,
        lastName: ctx.from?.last_name || undefined
      },
      create: {
        telegramId: userId,
        username: ctx.from?.username || "",
        firstName: ctx.from?.first_name || "",
        lastName: ctx.from?.last_name || ""
      }
    });

    logger.info("Sending start menu...");
    
    await ctx.reply("ü§ñ **AICEX AI Bot** - –í—ã–±–µ—Ä–∏—Ç–µ AI —Å–µ—Ä–≤–∏—Å:", {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: "üåê –í–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app: { url: "https://aicexonefrontend-production.up.railway.app/home" } }],
          [{ text: "üí¨ ChatGPT", callback_data: "chatgpt" }, { text: "üé® Midjourney", callback_data: "midjourney" }],
          [{ text: "üñºÔ∏è Freepik", callback_data: "freepik" }, { text: "üé¨ Runway", callback_data: "runway" }],
          [{ text: "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data: "settings" }, { text: "‚ùì –ü–æ–º–æ—â—å", callback_data: "help" }]
        ]
      }
    });
    
    logger.info("‚úÖ Start command completed successfully");
    
  } catch (error) {
    logger.error("Error in start command:", error);
    logger.error("Error stack:", (error as Error).stack);
    
    try {
      await ctx.reply("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞");
    } catch (replyError) {
      logger.error("Could not send error message:", replyError);
    }
  }
});

} // –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–ª–æ–∫ if (bot)

// üßπ –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
setInterval(() => {
  aiHandler.cleanupSessions();
  securityService.cleanupRateLimiter();
}, 30 * 60 * 1000);

// üóëÔ∏è –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∫–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤
setInterval(async () => {
  try {
    const { FileHandler } = await import("../utils/fileHandler");
    const fileHandler = new FileHandler();
    fileHandler.cleanupOldFiles(24); // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ 24 —á–∞—Å–æ–≤
    logger.info("Old temporary files cleaned up");
  } catch (error) {
    logger.error("Error cleaning up old files:", error);
  }
}, 6 * 60 * 60 * 1000);

// üìä –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
export async function startBot() {
  try {
    if (!bot) {
      logger.warn("Bot not initialized, skipping bot startup");
      return;
    }
    
    logger.info("üîÑ Initializing bot...");
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç
    const me = await bot.api.getMe();
    logger.info(`‚úÖ Bot verified: @${me.username} (${me.first_name})`);
    
    // –ò–°–ü–û–õ–¨–ó–£–ï–ú WEBHOOK –í–ú–ï–°–¢–û POLLING –¥–ª—è Railway
    const webhookUrl = `${process.env.BACKEND_URL || 'https://aicexaibot-production.up.railway.app'}/api/webhooks/telegram`;
    
    try {
      await bot.api.setWebhook(webhookUrl, {
        drop_pending_updates: true,
        allowed_updates: ["message", "callback_query"]
      });
      logger.info(`‚úÖ Webhook set to: ${webhookUrl}`);
    } catch (webhookError) {
      logger.error("Could not set webhook:", webhookError);
      throw webhookError;
    }
    
    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫
    bot.catch((err) => {
      logger.error("Bot error:", err);
    });
    
    logger.info("ü§ñ Bot configured with webhook successfully!");
    logger.info("‚úÖ Telegram bot ready to receive messages via webhook");
    
  } catch (error) {
    logger.error("Failed to start bot:", error);
    logger.error("Error details:", (error as Error).message);
    throw error;
  }
}

// Graceful shutdown
process.on("SIGINT", async () => {
  logger.info("Shutting down bot...");
  if (bot) {
    await bot.stop();
  }
  await prisma.$disconnect();
  process.exit(0);
});

process.on("SIGTERM", async () => {
  logger.info("Shutting down bot...");
  if (bot) {
    await bot.stop();
  }
  await prisma.$disconnect();
  process.exit(0);
});
